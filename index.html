<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="/icons/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Trackey!</title>
    <script type="module">
      //assets/index.8a76a908.js
      const p = function polyfill() {
        const relList = document.createElement("link").relList;
        if (relList && relList.supports && relList.supports("modulepreload")) {
          return;
        }
        for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
          processPreload(link);
        }
        new MutationObserver((mutations) => {
          for (const mutation of mutations) {
            if (mutation.type !== "childList") {
              continue;
            }
            for (const node of mutation.addedNodes) {
              if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
            }
          }
        }).observe(document, { childList: true, subtree: true });
        function getFetchOpts(script) {
          const fetchOpts = {};
          if (script.integrity) fetchOpts.integrity = script.integrity;
          if (script.referrerpolicy) fetchOpts.referrerPolicy = script.referrerpolicy;
          if (script.crossorigin === "use-credentials") fetchOpts.credentials = "include";
          else if (script.crossorigin === "anonymous") fetchOpts.credentials = "omit";
          else fetchOpts.credentials = "same-origin";
          return fetchOpts;
        }
        function processPreload(link) {
          if (link.ep)
            // ep marker = processed
            return;
          link.ep = true;
          // prepopulate the load record
          const fetchOpts = getFetchOpts(link);
          fetch(link.href, fetchOpts);
        }
      };
      true && p();

      function noop() {}
      const identity = (x) => x;
      function assign(tar, src) {
        // @ts-ignore
        for (const k in src) tar[k] = src[k];
        return tar;
      }
      function run(fn) {
        return fn();
      }
      function blank_object() {
        return Object.create(null);
      }
      function run_all(fns) {
        fns.forEach(run);
      }
      function is_function(thing) {
        return typeof thing === "function";
      }
      function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || (a && typeof a === "object") || typeof a === "function";
      }
      function is_empty(obj) {
        return Object.keys(obj).length === 0;
      }
      function subscribe(store, ...callbacks) {
        if (store == null) {
          return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
      }
      function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
      }
      function set_store_value(store, ret, value) {
        store.set(value);
        return ret;
      }
      function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
      }

      const is_client = typeof window !== "undefined";
      let now = is_client ? () => window.performance.now() : () => Date.now();
      let raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;

      const tasks = new Set();
      function run_tasks(now) {
        tasks.forEach((task) => {
          if (!task.c(now)) {
            tasks.delete(task);
            task.f();
          }
        });
        if (tasks.size !== 0) raf(run_tasks);
      }
      /**
       * Creates a new task that runs on each raf frame
       * until it returns a falsy value or is aborted
       */
      function loop(callback) {
        let task;
        if (tasks.size === 0) raf(run_tasks);
        return {
          promise: new Promise((fulfill) => {
            tasks.add((task = { c: callback, f: fulfill }));
          }),
          abort() {
            tasks.delete(task);
          },
        };
      }
      function append(target, node) {
        target.appendChild(node);
      }
      function get_root_for_style(node) {
        if (!node) return document;
        const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
        if (root && root.host) {
          return root;
        }
        return node.ownerDocument;
      }
      function append_empty_stylesheet(node) {
        const style_element = element("style");
        append_stylesheet(get_root_for_style(node), style_element);
        return style_element.sheet;
      }
      function append_stylesheet(node, style) {
        append(node.head || node, style);
      }
      function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
      }
      function detach(node) {
        node.parentNode.removeChild(node);
      }
      function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
          if (iterations[i]) iterations[i].d(detaching);
        }
      }
      function element(name) {
        return document.createElement(name);
      }
      function svg_element(name) {
        return document.createElementNS("http://www.w3.org/2000/svg", name);
      }
      function text(data) {
        return document.createTextNode(data);
      }
      function space() {
        return text(" ");
      }
      function empty() {
        return text("");
      }
      function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
      }
      function prevent_default(fn) {
        return function (event) {
          event.preventDefault();
          // @ts-ignore
          return fn.call(this, event);
        };
      }
      function attr(node, attribute, value) {
        if (value == null) node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
      }
      function to_number(value) {
        return value === "" ? null : +value;
      }
      function children(element) {
        return Array.from(element.childNodes);
      }
      function set_data(text, data) {
        data = "" + data;
        if (text.wholeText !== data) text.data = data;
      }
      function set_input_value(input, value) {
        input.value = value == null ? "" : value;
      }
      function set_style(node, key, value, important) {
        if (value === null) {
          node.style.removeProperty(key);
        } else {
          node.style.setProperty(key, value, important ? "important" : "");
        }
      }
      function toggle_class(element, name, toggle) {
        element.classList[toggle ? "add" : "remove"](name);
      }
      function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent("CustomEvent");
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
      }

      // we need to store the information for multiple documents because a Svelte application could also contain iframes
      // https://github.com/sveltejs/svelte/issues/3624
      const managed_styles = new Map();
      let active = 0;
      // https://github.com/darkskyapp/string-hash/blob/master/index.js
      function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
      }
      function create_style_information(doc, node) {
        const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
        managed_styles.set(doc, info);
        return info;
      }
      function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = "{\n";
        for (let p = 0; p <= 1; p += step) {
          const t = a + (b - a) * ease(p);
          keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = get_root_for_style(node);
        const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
        if (!rules[name]) {
          rules[name] = true;
          stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || "";
        node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
      }
      function delete_rule(node, name) {
        const previous = (node.style.animation || "").split(", ");
        const next = previous.filter(
          name
            ? (anim) => anim.indexOf(name) < 0 // remove specific animation
            : (anim) => anim.indexOf("__svelte") === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
          node.style.animation = next.join(", ");
          active -= deleted;
          if (!active) clear_rules();
        }
      }
      function clear_rules() {
        raf(() => {
          if (active) return;
          managed_styles.forEach((info) => {
            const { stylesheet } = info;
            let i = stylesheet.cssRules.length;
            while (i--) stylesheet.deleteRule(i);
            info.rules = {};
          });
          managed_styles.clear();
        });
      }

      let current_component;
      function set_current_component(component) {
        current_component = component;
      }
      function get_current_component() {
        if (!current_component) throw new Error("Function called outside component initialization");
        return current_component;
      }
      function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
      }
      function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
      }
      function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
          const callbacks = component.$$.callbacks[type];
          if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail);
            callbacks.slice().forEach((fn) => {
              fn.call(component, event);
            });
          }
        };
      }
      // TODO figure out if we still want to support
      // shorthand events, or if we want to implement
      // a real bubbling mechanism
      function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
          // @ts-ignore
          callbacks.slice().forEach((fn) => fn.call(this, event));
        }
      }

      const dirty_components = [];
      const binding_callbacks = [];
      const render_callbacks = [];
      const flush_callbacks = [];
      const resolved_promise = Promise.resolve();
      let update_scheduled = false;
      function schedule_update() {
        if (!update_scheduled) {
          update_scheduled = true;
          resolved_promise.then(flush);
        }
      }
      function tick() {
        schedule_update();
        return resolved_promise;
      }
      function add_render_callback(fn) {
        render_callbacks.push(fn);
      }
      function add_flush_callback(fn) {
        flush_callbacks.push(fn);
      }
      // flush() calls callbacks in this order:
      // 1. All beforeUpdate callbacks, in order: parents before children
      // 2. All bind:this callbacks, in reverse order: children before parents.
      // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
      //    for afterUpdates called during the initial onMount, which are called in
      //    reverse order: children before parents.
      // Since callbacks might update component values, which could trigger another
      // call to flush(), the following steps guard against this:
      // 1. During beforeUpdate, any updated components will be added to the
      //    dirty_components array and will cause a reentrant call to flush(). Because
      //    the flush index is kept outside the function, the reentrant call will pick
      //    up where the earlier call left off and go through all dirty components. The
      //    current_component value is saved and restored so that the reentrant call will
      //    not interfere with the "parent" flush() call.
      // 2. bind:this callbacks cannot trigger new flush() calls.
      // 3. During afterUpdate, any updated components will NOT have their afterUpdate
      //    callback called a second time; the seen_callbacks set, outside the flush()
      //    function, guarantees this behavior.
      const seen_callbacks = new Set();
      let flushidx = 0; // Do *not* move this inside the flush() function
      function flush() {
        const saved_component = current_component;
        do {
          // first, call beforeUpdate functions
          // and update components
          while (flushidx < dirty_components.length) {
            const component = dirty_components[flushidx];
            flushidx++;
            set_current_component(component);
            update(component.$$);
          }
          set_current_component(null);
          dirty_components.length = 0;
          flushidx = 0;
          while (binding_callbacks.length) binding_callbacks.pop()();
          // then, once components are updated, call
          // afterUpdate functions. This may cause
          // subsequent updates...
          for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
              // ...so guard against infinite loops
              seen_callbacks.add(callback);
              callback();
            }
          }
          render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
          flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
      }
      function update($$) {
        if ($$.fragment !== null) {
          $$.update();
          run_all($$.before_update);
          const dirty = $$.dirty;
          $$.dirty = [-1];
          $$.fragment && $$.fragment.p($$.ctx, dirty);
          $$.after_update.forEach(add_render_callback);
        }
      }

      let promise;
      function wait() {
        if (!promise) {
          promise = Promise.resolve();
          promise.then(() => {
            promise = null;
          });
        }
        return promise;
      }
      function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
      }
      const outroing = new Set();
      let outros;
      function group_outros() {
        outros = {
          r: 0,
          c: [],
          p: outros, // parent group
        };
      }
      function check_outros() {
        if (!outros.r) {
          run_all(outros.c);
        }
        outros = outros.p;
      }
      function transition_in(block, local) {
        if (block && block.i) {
          outroing.delete(block);
          block.i(local);
        }
      }
      function transition_out(block, local, detach, callback) {
        if (block && block.o) {
          if (outroing.has(block)) return;
          outroing.add(block);
          outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
              if (detach) block.d(1);
              callback();
            }
          });
          block.o(local);
        }
      }
      const null_transition = { duration: 0 };
      function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
          if (animation_name) delete_rule(node, animation_name);
        }
        function go() {
          const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
          if (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
          tick(0, 1);
          const start_time = now() + delay;
          const end_time = start_time + duration;
          if (task) task.abort();
          running = true;
          add_render_callback(() => dispatch(node, true, "start"));
          task = loop((now) => {
            if (running) {
              if (now >= end_time) {
                tick(1, 0);
                dispatch(node, true, "end");
                cleanup();
                return (running = false);
              }
              if (now >= start_time) {
                const t = easing((now - start_time) / duration);
                tick(t, 1 - t);
              }
            }
            return running;
          });
        }
        let started = false;
        return {
          start() {
            if (started) return;
            started = true;
            delete_rule(node);
            if (is_function(config)) {
              config = config();
              wait().then(go);
            } else {
              go();
            }
          },
          invalidate() {
            started = false;
          },
          end() {
            if (running) {
              cleanup();
              running = false;
            }
          },
        };
      }
      function create_out_transition(node, fn, params) {
        let config = fn(node, params);
        let running = true;
        let animation_name;
        const group = outros;
        group.r += 1;
        function go() {
          const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
          if (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
          const start_time = now() + delay;
          const end_time = start_time + duration;
          add_render_callback(() => dispatch(node, false, "start"));
          loop((now) => {
            if (running) {
              if (now >= end_time) {
                tick(0, 1);
                dispatch(node, false, "end");
                if (!--group.r) {
                  // this will result in `end()` being called,
                  // so we don't need to clean up here
                  run_all(group.c);
                }
                return false;
              }
              if (now >= start_time) {
                const t = easing((now - start_time) / duration);
                tick(1 - t, t);
              }
            }
            return running;
          });
        }
        if (is_function(config)) {
          wait().then(() => {
            // @ts-ignore
            config = config();
            go();
          });
        } else {
          go();
        }
        return {
          end(reset) {
            if (reset && config.tick) {
              config.tick(1, 0);
            }
            if (running) {
              if (animation_name) delete_rule(node, animation_name);
              running = false;
            }
          },
        };
      }
      function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
          if (animation_name) delete_rule(node, animation_name);
        }
        function init(program, duration) {
          const d = program.b - t;
          duration *= Math.abs(d);
          return {
            a: t,
            b: program.b,
            d,
            duration,
            start: program.start,
            end: program.start + duration,
            group: program.group,
          };
        }
        function go(b) {
          const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
          const program = {
            start: now() + delay,
            b,
          };
          if (!b) {
            // @ts-ignore todo: improve typings
            program.group = outros;
            outros.r += 1;
          }
          if (running_program || pending_program) {
            pending_program = program;
          } else {
            // if this is an intro, and there's a delay, we need to do
            // an initial tick and/or apply CSS animation immediately
            if (css) {
              clear_animation();
              animation_name = create_rule(node, t, b, duration, delay, easing, css);
            }
            if (b) tick(0, 1);
            running_program = init(program, duration);
            add_render_callback(() => dispatch(node, b, "start"));
            loop((now) => {
              if (pending_program && now > pending_program.start) {
                running_program = init(pending_program, duration);
                pending_program = null;
                dispatch(node, running_program.b, "start");
                if (css) {
                  clear_animation();
                  animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                }
              }
              if (running_program) {
                if (now >= running_program.end) {
                  tick((t = running_program.b), 1 - t);
                  dispatch(node, running_program.b, "end");
                  if (!pending_program) {
                    // we're done
                    if (running_program.b) {
                      // intro â€” we can tidy up immediately
                      clear_animation();
                    } else {
                      // outro â€” needs to be coordinated
                      if (!--running_program.group.r) run_all(running_program.group.c);
                    }
                  }
                  running_program = null;
                } else if (now >= running_program.start) {
                  const p = now - running_program.start;
                  t = running_program.a + running_program.d * easing(p / running_program.duration);
                  tick(t, 1 - t);
                }
              }
              return !!(running_program || pending_program);
            });
          }
        }
        return {
          run(b) {
            if (is_function(config)) {
              wait().then(() => {
                // @ts-ignore
                config = config();
                go(b);
              });
            } else {
              go(b);
            }
          },
          end() {
            clear_animation();
            running_program = pending_program = null;
          },
        };
      }

      const globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;

      function destroy_block(block, lookup) {
        block.d(1);
        lookup.delete(block.key);
      }
      function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
          lookup.delete(block.key);
        });
      }
      function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--) old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
          const child_ctx = get_context(ctx, list, i);
          const key = get_key(child_ctx);
          let block = lookup.get(key);
          if (!block) {
            block = create_each_block(key, child_ctx);
            block.c();
          } else if (dynamic) {
            block.p(child_ctx, dirty);
          }
          new_lookup.set(key, (new_blocks[i] = block));
          if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
          transition_in(block, 1);
          block.m(node, next);
          lookup.set(block.key, block);
          next = block.first;
          n--;
        }
        while (o && n) {
          const new_block = new_blocks[n - 1];
          const old_block = old_blocks[o - 1];
          const new_key = new_block.key;
          const old_key = old_block.key;
          if (new_block === old_block) {
            // do nothing
            next = new_block.first;
            o--;
            n--;
          } else if (!new_lookup.has(old_key)) {
            // remove old block
            destroy(old_block, lookup);
            o--;
          } else if (!lookup.has(new_key) || will_move.has(new_key)) {
            insert(new_block);
          } else if (did_move.has(old_key)) {
            o--;
          } else if (deltas.get(new_key) > deltas.get(old_key)) {
            did_move.add(new_key);
            insert(new_block);
          } else {
            will_move.add(old_key);
            o--;
          }
        }
        while (o--) {
          const old_block = old_blocks[o];
          if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);
        }
        while (n) insert(new_blocks[n - 1]);
        return new_blocks;
      }

      function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
          component.$$.bound[index] = callback;
          callback(component.$$.ctx[index]);
        }
      }
      function create_component(block) {
        block && block.c();
      }
      function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
          // onMount happens before the initial afterUpdate
          add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
              on_destroy.push(...new_on_destroy);
            } else {
              // Edge case - component was destroyed immediately,
              // most likely as a result of a binding initialising
              run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
          });
        }
        after_update.forEach(add_render_callback);
      }
      function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
          run_all($$.on_destroy);
          $$.fragment && $$.fragment.d(detaching);
          // TODO null out other refs, including component.$$ (but need to
          // preserve final state?)
          $$.on_destroy = $$.fragment = null;
          $$.ctx = [];
        }
      }
      function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
          dirty_components.push(component);
          schedule_update();
          component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;
      }
      function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = (component.$$ = {
          fragment: null,
          ctx: null,
          // state
          props,
          update: noop,
          not_equal,
          bound: blank_object(),
          // lifecycle
          on_mount: [],
          on_destroy: [],
          on_disconnect: [],
          before_update: [],
          after_update: [],
          context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
          // everything else
          callbacks: blank_object(),
          dirty,
          skip_bound: false,
          root: options.target || parent_component.$$.root,
        });
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
          ? instance(component, options.props || {}, (i, ret, ...rest) => {
              const value = rest.length ? rest[0] : ret;
              if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {
                if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
                if (ready) make_dirty(component, i);
              }
              return ret;
            })
          : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
          if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
          } else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
          }
          if (options.intro) transition_in(component.$$.fragment);
          mount_component(component, options.target, options.anchor, options.customElement);
          flush();
        }
        set_current_component(parent_component);
      }
      /**
       * Base class for Svelte components. Used when dev=false.
       */
      class SvelteComponent {
        $destroy() {
          destroy_component(this, 1);
          this.$destroy = noop;
        }
        $on(type, callback) {
          const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
          callbacks.push(callback);
          return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1) callbacks.splice(index, 1);
          };
        }
        $set($$props) {
          if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
          }
        }
      }

      /* src/icons/TickIcon.svelte generated by Svelte v3.46.4 */

      function create_fragment$8(ctx) {
        let svg;
        let defs;
        let style;
        let t;
        let g0;
        let g2;
        let g1;
        let rect;
        let polyline;

        return {
          c() {
            svg = svg_element("svg");
            defs = svg_element("defs");
            style = svg_element("style");
            t = text(".de,\n      .ee {\n        fill: none;\n      }\n      .ee {\n        stroke: var(--lightGrey1);\n        stroke-miterlimit: 10;\n        stroke-width: 3px;\n      }\n    ");
            g0 = svg_element("g");
            g2 = svg_element("g");
            g1 = svg_element("g");
            rect = svg_element("rect");
            polyline = svg_element("polyline");
            attr(g0, "id", "ae");
            attr(rect, "class", "d");
            attr(rect, "width", "76.87");
            attr(rect, "height", "76.87");
            attr(polyline, "class", "ee");
            attr(polyline, "points", "66.38 22.98 25.08 53.89 11.94 41.99");
            attr(g1, "id", "ce");
            attr(g2, "id", "be");
            attr(svg, "xmlns", "http://www.w3.org/2000/svg");
            attr(svg, "viewBox", "0 0 76.87 76.87");
          },
          m(target, anchor) {
            insert(target, svg, anchor);
            append(svg, defs);
            append(defs, style);
            append(style, t);
            append(svg, g0);
            append(svg, g2);
            append(g2, g1);
            append(g1, rect);
            append(g1, polyline);
          },
          p: noop,
          i: noop,
          o: noop,
          d(detaching) {
            if (detaching) detach(svg);
          },
        };
      }

      class TickIcon extends SvelteComponent {
        constructor(options) {
          super();
          init(this, options, null, create_fragment$8, safe_not_equal, {});
        }
      }

      /* src/icons/AddIcon.svelte generated by Svelte v3.46.4 */

      function create_fragment$7(ctx) {
        let svg;
        let defs;
        let style;
        let t;
        let g0;
        let g2;
        let g1;
        let rect;
        let line0;
        let line1;

        return {
          c() {
            svg = svg_element("svg");
            defs = svg_element("defs");
            style = svg_element("style");
            t = text(".d {\n        fill: none;\n      }\n\n      .e {\n        stroke: var(--strokeColor);\n        stroke-miterlimit: 10;\n        stroke-width: var(--strokeWidth);\n      }\n    ");
            g0 = svg_element("g");
            g2 = svg_element("g");
            g1 = svg_element("g");
            rect = svg_element("rect");
            line0 = svg_element("line");
            line1 = svg_element("line");
            attr(g0, "id", "a");
            attr(rect, "class", "d");
            attr(rect, "width", "76.87");
            attr(rect, "height", "76.87");
            attr(line0, "class", "e");
            attr(line0, "x1", "38.43");
            attr(line0, "y1", "12.85");
            attr(line0, "x2", "38.43");
            attr(line0, "y2", "64.02");
            attr(line1, "class", "e");
            attr(line1, "x1", "64.02");
            attr(line1, "y1", "38.43");
            attr(line1, "x2", "12.85");
            attr(line1, "y2", "38.43");
            attr(g1, "id", "c");
            attr(g2, "id", "b");
            attr(svg, "xmlns", "http://www.w3.org/2000/svg");
            attr(svg, "viewBox", "0 0 76.87 76.87");
            set_style(svg, "--strokeColor", /*strokeColor*/ ctx[0]);
            set_style(svg, "--strokeWidth", /*strokeWidth*/ ctx[1] + "rem");
          },
          m(target, anchor) {
            insert(target, svg, anchor);
            append(svg, defs);
            append(defs, style);
            append(style, t);
            append(svg, g0);
            append(svg, g2);
            append(g2, g1);
            append(g1, rect);
            append(g1, line0);
            append(g1, line1);
          },
          p(ctx, [dirty]) {
            if (dirty & /*strokeColor*/ 1) {
              set_style(svg, "--strokeColor", /*strokeColor*/ ctx[0]);
            }

            if (dirty & /*strokeWidth*/ 2) {
              set_style(svg, "--strokeWidth", /*strokeWidth*/ ctx[1] + "rem");
            }
          },
          i: noop,
          o: noop,
          d(detaching) {
            if (detaching) detach(svg);
          },
        };
      }

      function instance$8($$self, $$props, $$invalidate) {
        let { strokeColor = "white" } = $$props;
        let { strokeWidth = "0.2" } = $$props;

        $$self.$$set = ($$props) => {
          if ("strokeColor" in $$props) $$invalidate(0, (strokeColor = $$props.strokeColor));
          if ("strokeWidth" in $$props) $$invalidate(1, (strokeWidth = $$props.strokeWidth));
        };

        return [strokeColor, strokeWidth];
      }

      class AddIcon extends SvelteComponent {
        constructor(options) {
          super();
          init(this, options, instance$8, create_fragment$7, safe_not_equal, { strokeColor: 0, strokeWidth: 1 });
        }
      }

      // utility functions used in the project
      // prepend a zero to integers smaller than 10 (used for the second and minute values)
      function zeroPadded(number) {
        return number >= 10 ? number.toString() : `0${number}`;
      }
      // consider the last digit of the input number (used for the tenths of seconds)
      function lastDigit(number) {
        return number.toString()[number.toString().length - 1];
      }

      /* format time in the following format
mm:ss:t
zero padded minutes, zero padded seconds, tenths of seconds
*/
      function formatTime(milliseconds) {
        const mm = zeroPadded(Math.floor(milliseconds / 1000 / 60));
        const ss = zeroPadded(Math.floor(milliseconds / 1000) % 60);
        lastDigit(Math.floor(milliseconds / 100));
        return `${mm}:${ss}`;
      }

      // export function formatTime(milliseconds) {
      //     const mm = zeroPadded(Math.floor(milliseconds / 1000 / 60));
      //     const ss = zeroPadded(Math.floor(milliseconds / 1000) % 60);
      //     const t = lastDigit(Math.floor(milliseconds / 100));
      //     return `${mm}:${ss}.${t}`;
      // }

      const getDaysArray = function (start, end) {
        for (var arr = [], dt = new Date(start); dt <= end; dt.setDate(dt.getDate() + 1)) {
          arr.push(new Date(dt));
        }
        return arr;
      };

      const addDays = (date, days) => {
        var result = new Date(date);
        result.setDate(result.getDate() + days);
        return result;
      };

      //GET FIRST DAT OF THE WEEK
      function firstDayOfWeek(dateObject, firstDayOfWeekIndex) {
        const dayOfWeek = dateObject.getDay(),
          firstDayOfWeek = new Date(dateObject),
          diff = dayOfWeek >= firstDayOfWeekIndex ? dayOfWeek - firstDayOfWeekIndex : 6 - dayOfWeek;

        firstDayOfWeek.setDate(dateObject.getDate() - diff);
        firstDayOfWeek.setHours(0, 0, 0, 0);

        return firstDayOfWeek;
      }

      const subscriber_queue = [];
      /**
       * Creates a `Readable` store that allows reading by subscription.
       * @param value initial value
       * @param {StartStopNotifier}start start and stop notifications for subscriptions
       */
      function readable(value, start) {
        return {
          subscribe: writable(value, start).subscribe,
        };
      }
      /**
       * Create a `Writable` store that allows both updating and reading by subscription.
       * @param {*=}value initial value
       * @param {StartStopNotifier=}start start and stop notifications for subscriptions
       */
      function writable(value, start = noop) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
          if (safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) {
              // store is ready
              const run_queue = !subscriber_queue.length;
              for (const subscriber of subscribers) {
                subscriber[1]();
                subscriber_queue.push(subscriber, value);
              }
              if (run_queue) {
                for (let i = 0; i < subscriber_queue.length; i += 2) {
                  subscriber_queue[i][0](subscriber_queue[i + 1]);
                }
                subscriber_queue.length = 0;
              }
            }
          }
        }
        function update(fn) {
          set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
          const subscriber = [run, invalidate];
          subscribers.add(subscriber);
          if (subscribers.size === 1) {
            stop = start(set) || noop;
          }
          run(value);
          return () => {
            subscribers.delete(subscriber);
            if (subscribers.size === 0) {
              stop();
              stop = null;
            }
          };
        }
        return { set, update, subscribe };
      }

      function cubicOut(t) {
        const f = t - 1.0;
        return f * f * f + 1.0;
      }

      /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

      function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
          }
        return t;
      }
      function slide(node, { delay = 0, duration = 400, easing = cubicOut } = {}) {
        const style = getComputedStyle(node);
        const opacity = +style.opacity;
        const height = parseFloat(style.height);
        const padding_top = parseFloat(style.paddingTop);
        const padding_bottom = parseFloat(style.paddingBottom);
        const margin_top = parseFloat(style.marginTop);
        const margin_bottom = parseFloat(style.marginBottom);
        const border_top_width = parseFloat(style.borderTopWidth);
        const border_bottom_width = parseFloat(style.borderBottomWidth);
        return {
          delay,
          duration,
          easing,
          css: (t) =>
            "overflow: hidden;" +
            `opacity: ${Math.min(t * 20, 1) * opacity};` +
            `height: ${t * height}px;` +
            `padding-top: ${t * padding_top}px;` +
            `padding-bottom: ${t * padding_bottom}px;` +
            `margin-top: ${t * margin_top}px;` +
            `margin-bottom: ${t * margin_bottom}px;` +
            `border-top-width: ${t * border_top_width}px;` +
            `border-bottom-width: ${t * border_bottom_width}px;`,
        };
      }
      function crossfade(_a) {
        var { fallback } = _a,
          defaults = __rest(_a, ["fallback"]);
        const to_receive = new Map();
        const to_send = new Map();
        function crossfade(from, node, params) {
          const { delay = 0, duration = (d) => Math.sqrt(d) * 30, easing = cubicOut } = assign(assign({}, defaults), params);
          const to = node.getBoundingClientRect();
          const dx = from.left - to.left;
          const dy = from.top - to.top;
          const dw = from.width / to.width;
          const dh = from.height / to.height;
          const d = Math.sqrt(dx * dx + dy * dy);
          const style = getComputedStyle(node);
          const transform = style.transform === "none" ? "" : style.transform;
          const opacity = +style.opacity;
          return {
            delay,
            duration: is_function(duration) ? duration(d) : duration,
            easing,
            css: (t, u) => `
				opacity: ${t * opacity};
				transform-origin: top left;
				transform: ${transform} translate(${u * dx}px,${u * dy}px) scale(${t + (1 - t) * dw}, ${t + (1 - t) * dh});
			`,
          };
        }
        function transition(items, counterparts, intro) {
          return (node, params) => {
            items.set(params.key, {
              rect: node.getBoundingClientRect(),
            });
            return () => {
              if (counterparts.has(params.key)) {
                const { rect } = counterparts.get(params.key);
                counterparts.delete(params.key);
                return crossfade(rect, node, params);
              }
              // if the node is disappearing altogether
              // (i.e. wasn't claimed by the other list)
              // then we need to supply an outro
              items.delete(params.key);
              return fallback && fallback(node, params, intro);
            };
          };
        }
        return [transition(to_send, to_receive, false), transition(to_receive, to_send, true)];
      }

      var Calendar_svelte_svelte_type_style_lang = "";

      var Time_svelte_svelte_type_style_lang = "";

      var SveltyPicker_svelte_svelte_type_style_lang = "";

      var TaskForm_svelte_svelte_type_style_lang = "";

      /* src/TaskForm.svelte generated by Svelte v3.46.4 */

      function get_each_context$3(ctx, list, i) {
        const child_ctx = ctx.slice();
        child_ctx[28] = list[i];
        return child_ctx;
      }

      function get_each_context_1$2(ctx, list, i) {
        const child_ctx = ctx.slice();
        child_ctx[31] = list[i];
        return child_ctx;
      }

      function get_each_context_2$1(ctx, list, i) {
        const child_ctx = ctx.slice();
        child_ctx[34] = list[i];
        return child_ctx;
      }

      // (98:8) {#each trackForHorizonOptions as trackForHorizonOption}
      function create_each_block_2$1(ctx) {
        let div;
        let input;
        let input_id_value;
        let input_label_value;
        let input_value_value;
        let t;
        let mounted;
        let dispose;

        return {
          c() {
            div = element("div");
            input = element("input");
            t = space();
            attr(input, "id", (input_id_value = /*trackForHorizonOption*/ ctx[34]));
            attr(input, "label", (input_label_value = /*trackForHorizonOption*/ ctx[34]));
            attr(input, "type", "radio");
            input.__value = input_value_value = /*trackForHorizonOption*/ ctx[34];
            input.value = input.__value;
            attr(input, "class", "svelte-1m7lz7i");
            /*$$binding_groups*/ ctx[20][0].push(input);
            attr(div, "class", "option");
          },
          m(target, anchor) {
            insert(target, div, anchor);
            append(div, input);
            input.checked = input.__value === /*newTask*/ ctx[0].horizonEntry;
            append(div, t);

            if (!mounted) {
              dispose = listen(input, "change", /*input_change_handler*/ ctx[19]);
              mounted = true;
            }
          },
          p(ctx, dirty) {
            if (dirty[0] & /*newTask*/ 1) {
              input.checked = input.__value === /*newTask*/ ctx[0].horizonEntry;
            }
          },
          d(detaching) {
            if (detaching) detach(div);
            /*$$binding_groups*/ ctx[20][0].splice(/*$$binding_groups*/ ctx[20][0].indexOf(input), 1);
            mounted = false;
            dispose();
          },
        };
      }

      // (116:6) {#each taskTypes as taskType}
      function create_each_block_1$2(ctx) {
        let div;
        let input;
        let input_id_value;
        let input_label_value;
        let input_value_value;
        let t;
        let mounted;
        let dispose;

        return {
          c() {
            div = element("div");
            input = element("input");
            t = space();
            attr(input, "id", (input_id_value = /*taskType*/ ctx[31]));
            attr(input, "label", (input_label_value = /*taskType*/ ctx[31]));
            attr(input, "type", "radio");
            input.__value = input_value_value = /*taskType*/ ctx[31];
            input.value = input.__value;
            attr(input, "class", "svelte-1m7lz7i");
            /*$$binding_groups*/ ctx[20][1].push(input);
            attr(div, "class", "option");
          },
          m(target, anchor) {
            insert(target, div, anchor);
            append(div, input);
            input.checked = input.__value === /*newTask*/ ctx[0].taskType;
            append(div, t);

            if (!mounted) {
              dispose = listen(input, "change", /*input_change_handler_1*/ ctx[21]);
              mounted = true;
            }
          },
          p(ctx, dirty) {
            if (dirty[0] & /*newTask*/ 1) {
              input.checked = input.__value === /*newTask*/ ctx[0].taskType;
            }
          },
          d(detaching) {
            if (detaching) detach(div);
            /*$$binding_groups*/ ctx[20][1].splice(/*$$binding_groups*/ ctx[20][1].indexOf(input), 1);
            mounted = false;
            dispose();
          },
        };
      }

      // (128:6) {#each newTask.todos as todo}
      function create_each_block$3(ctx) {
        let li;
        let t0_value = /*todo*/ ctx[28].name + "";
        let t0;
        let t1;
        let mounted;
        let dispose;

        function click_handler() {
          return /*click_handler*/ ctx[22](/*todo*/ ctx[28]);
        }

        return {
          c() {
            li = element("li");
            t0 = text(t0_value);
            t1 = space();
            attr(li, "class", "option completed svelte-1m7lz7i");
            toggle_class(li, "completed", /*todo*/ ctx[28].completed);
          },
          m(target, anchor) {
            insert(target, li, anchor);
            append(li, t0);
            append(li, t1);

            if (!mounted) {
              dispose = listen(li, "click", click_handler);
              mounted = true;
            }
          },
          p(new_ctx, dirty) {
            ctx = new_ctx;
            if (dirty[0] & /*newTask*/ 1 && t0_value !== (t0_value = /*todo*/ ctx[28].name + "")) set_data(t0, t0_value);

            if (dirty[0] & /*newTask*/ 1) {
              toggle_class(li, "completed", /*todo*/ ctx[28].completed);
            }
          },
          d(detaching) {
            if (detaching) detach(li);
            mounted = false;
            dispose();
          },
        };
      }

      // (141:6) {:else}
      function create_else_block$1(ctx) {
        let button;
        let mounted;
        let dispose;

        return {
          c() {
            button = element("button");
            button.textContent = "Add a to-do";
            attr(button, "class", "addToDo svelte-1m7lz7i");
          },
          m(target, anchor) {
            insert(target, button, anchor);

            if (!mounted) {
              dispose = listen(button, "click", prevent_default(/*showNewToDoFunc*/ ctx[9]));
              mounted = true;
            }
          },
          p: noop,
          d(detaching) {
            if (detaching) detach(button);
            mounted = false;
            dispose();
          },
        };
      }

      // (135:6) {#if showNewToDo === true}
      function create_if_block$2(ctx) {
        let input;
        let t0;
        let div;
        let button0;
        let t2;
        let button1;
        let mounted;
        let dispose;

        return {
          c() {
            input = element("input");
            t0 = space();
            div = element("div");
            button0 = element("button");
            button0.textContent = "Add";
            t2 = space();
            button1 = element("button");
            button1.textContent = "Cancel";
            attr(input, "type", "text");
            attr(input, "name", "todo");
            attr(input, "placeholder", "To-do");
            attr(button0, "class", "svelte-1m7lz7i");
            attr(button1, "class", "svelte-1m7lz7i");
            attr(div, "class", "toDoButtonsWrapper svelte-1m7lz7i");
          },
          m(target, anchor) {
            insert(target, input, anchor);
            set_input_value(input, /*newTodoText*/ ctx[2]);
            /*input_binding*/ ctx[24](input);
            insert(target, t0, anchor);
            insert(target, div, anchor);
            append(div, button0);
            append(div, t2);
            append(div, button1);

            if (!mounted) {
              dispose = [
                listen(input, "input", /*input_input_handler*/ ctx[23]),
                listen(button0, "click", prevent_default(/*addNewTodo*/ ctx[10])),
                listen(button1, "click", prevent_default(/*cancelTodo*/ ctx[11])),
              ];

              mounted = true;
            }
          },
          p(ctx, dirty) {
            if (dirty[0] & /*newTodoText*/ 4 && input.value !== /*newTodoText*/ ctx[2]) {
              set_input_value(input, /*newTodoText*/ ctx[2]);
            }
          },
          d(detaching) {
            if (detaching) detach(input);
            /*input_binding*/ ctx[24](null);
            if (detaching) detach(t0);
            if (detaching) detach(div);
            mounted = false;
            run_all(dispose);
          },
        };
      }

      function create_fragment$6(ctx) {
        let form;
        let fieldset0;
        let label0;
        let t1;
        let input0;
        let t2;
        let fieldset1;
        let label1;
        let t4;
        let input1;
        let t5;
        let div1;
        let fieldset2;
        let label2;
        let t7;
        let input2;
        let t8;
        let fieldset3;
        let label3;
        let t10;
        let div0;
        let t11;
        let fieldset4;
        let label4;
        let t13;
        let div2;
        let t14;
        let fieldset6;
        let label5;
        let t16;
        let ul;
        let t17;
        let fieldset5;
        let mounted;
        let dispose;
        let each_value_2 = /*trackForHorizonOptions*/ ctx[8];
        let each_blocks_2 = [];

        for (let i = 0; i < each_value_2.length; i += 1) {
          each_blocks_2[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
        }

        let each_value_1 = /*taskTypes*/ ctx[7];
        let each_blocks_1 = [];

        for (let i = 0; i < each_value_1.length; i += 1) {
          each_blocks_1[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
        }

        let each_value = /*newTask*/ ctx[0].todos;
        let each_blocks = [];

        for (let i = 0; i < each_value.length; i += 1) {
          each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
        }

        function select_block_type(ctx, dirty) {
          if (/*showNewToDo*/ ctx[3] === true) return create_if_block$2;
          return create_else_block$1;
        }

        let current_block_type = select_block_type(ctx);
        let if_block = current_block_type(ctx);

        return {
          c() {
            form = element("form");
            fieldset0 = element("fieldset");
            label0 = element("label");
            label0.textContent = "Task name";
            t1 = space();
            input0 = element("input");
            t2 = space();
            fieldset1 = element("fieldset");
            label1 = element("label");
            label1.textContent = "Short name";
            t4 = space();
            input1 = element("input");
            t5 = space();
            div1 = element("div");
            fieldset2 = element("fieldset");
            label2 = element("label");
            label2.textContent = "Duration (in hours)";
            t7 = space();
            input2 = element("input");
            t8 = space();
            fieldset3 = element("fieldset");
            label3 = element("label");
            // label3.textContent = "Track for Horizon timesheet";
            t10 = space();
            div0 = element("div");

            for (let i = 0; i < each_blocks_2.length; i += 1) {
              each_blocks_2[i].c();
            }

            t11 = space();
            fieldset4 = element("fieldset");
            label4 = element("label");
            label4.textContent = "Task type";
            t13 = space();
            div2 = element("div");

            for (let i = 0; i < each_blocks_1.length; i += 1) {
              each_blocks_1[i].c();
            }

            t14 = space();
            fieldset6 = element("fieldset");
            label5 = element("label");
            label5.textContent = "To-Dos";
            t16 = space();
            ul = element("ul");

            for (let i = 0; i < each_blocks.length; i += 1) {
              each_blocks[i].c();
            }

            t17 = space();
            fieldset5 = element("fieldset");
            if_block.c();
            attr(label0, "for", "taskName");
            attr(input0, "id", "taskName");
            attr(input0, "type", "text");
            attr(input0, "name", "name");
            attr(input0, "placeholder", "Full task name matching horizon project entry");
            attr(input0, "class", "svelte-1m7lz7i");
            toggle_class(input0, "required", !(/*nameValidated*/ ctx[6]));
            attr(fieldset0, "class", "svelte-1m7lz7i");
            attr(label1, "for", "shortName");
            attr(input1, "id", "shortName");
            attr(input1, "type", "text");
            attr(input1, "name", "name");
            attr(input1, "placeholder", "A short identifier");
            attr(input1, "class", "svelte-1m7lz7i");
            toggle_class(input1, "required", !(/*shortNameValidated*/ ctx[5]));
            attr(fieldset1, "class", "svelte-1m7lz7i");
            attr(label2, "for", "dueDate");
            attr(input2, "type", "number");
            attr(fieldset2, "class", "svelte-1m7lz7i");
            attr(label3, "for", "horizonEntry");
            attr(div0, "class", "options svelte-1m7lz7i");
            attr(fieldset3, "class", "svelte-1m7lz7i");
            attr(div1, "class", "twoColumn svelte-1m7lz7i");
            attr(label4, "for", "type");
            attr(div2, "class", "options svelte-1m7lz7i");
            attr(fieldset4, "class", "svelte-1m7lz7i");
            attr(label5, "for", "type");
            attr(ul, "class", "ToDosList svelte-1m7lz7i");
            toggle_class(ul, "hidden", /*newTask*/ ctx[0].todos.length < 1);
            attr(fieldset5, "class", "newToDo svelte-1m7lz7i");
            attr(fieldset6, "class", "svelte-1m7lz7i");
            attr(form, "class", "svelte-1m7lz7i");
          },
          m(target, anchor) {
            insert(target, form, anchor);
            append(form, fieldset0);
            append(fieldset0, label0);
            /*label0_binding*/ ctx[15](label0);
            append(fieldset0, t1);
            append(fieldset0, input0);
            set_input_value(input0, /*newTask*/ ctx[0].name);
            append(form, t2);
            append(form, fieldset1);
            append(fieldset1, label1);
            append(fieldset1, t4);
            append(fieldset1, input1);
            set_input_value(input1, /*newTask*/ ctx[0].shortname);
            append(form, t5);
            append(form, div1);
            append(div1, fieldset2);
            append(fieldset2, label2);
            append(fieldset2, t7);
            append(fieldset2, input2);
            set_input_value(input2, /*newTask*/ ctx[0].duration);
            append(div1, t8);
            append(div1, fieldset3);
            append(fieldset3, label3);
            append(fieldset3, t10);
            append(fieldset3, div0);

            for (let i = 0; i < each_blocks_2.length; i += 1) {
              each_blocks_2[i].m(div0, null);
            }

            append(form, t11);
            append(form, fieldset4);
            append(fieldset4, label4);
            append(fieldset4, t13);
            append(fieldset4, div2);

            for (let i = 0; i < each_blocks_1.length; i += 1) {
              each_blocks_1[i].m(div2, null);
            }

            append(form, t14);
            append(form, fieldset6);
            append(fieldset6, label5);
            append(fieldset6, t16);
            append(fieldset6, ul);

            for (let i = 0; i < each_blocks.length; i += 1) {
              each_blocks[i].m(ul, null);
            }

            append(fieldset6, t17);
            append(fieldset6, fieldset5);
            if_block.m(fieldset5, null);

            if (!mounted) {
              dispose = [
                listen(input0, "input", /*input0_input_handler*/ ctx[16]),
                listen(input1, "input", /*input1_input_handler*/ ctx[17]),
                listen(input2, "input", /*input2_input_handler*/ ctx[18]),
                listen(form, "submit", prevent_default(/*submit_handler*/ ctx[14])),
              ];

              mounted = true;
            }
          },
          p(ctx, dirty) {
            if (dirty[0] & /*newTask*/ 1 && input0.value !== /*newTask*/ ctx[0].name) {
              set_input_value(input0, /*newTask*/ ctx[0].name);
            }

            if (dirty[0] & /*nameValidated*/ 64) {
              toggle_class(input0, "required", !(/*nameValidated*/ ctx[6]));
            }

            if (dirty[0] & /*newTask*/ 1 && input1.value !== /*newTask*/ ctx[0].shortname) {
              set_input_value(input1, /*newTask*/ ctx[0].shortname);
            }

            if (dirty[0] & /*shortNameValidated*/ 32) {
              toggle_class(input1, "required", !(/*shortNameValidated*/ ctx[5]));
            }

            if (dirty[0] & /*newTask*/ 1 && to_number(input2.value) !== /*newTask*/ ctx[0].duration) {
              set_input_value(input2, /*newTask*/ ctx[0].duration);
            }

            if (dirty[0] & /*trackForHorizonOptions, newTask*/ 257) {
              each_value_2 = /*trackForHorizonOptions*/ ctx[8];
              let i;

              for (i = 0; i < each_value_2.length; i += 1) {
                const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

                if (each_blocks_2[i]) {
                  each_blocks_2[i].p(child_ctx, dirty);
                } else {
                  each_blocks_2[i] = create_each_block_2$1(child_ctx);
                  each_blocks_2[i].c();
                  each_blocks_2[i].m(div0, null);
                }
              }

              for (; i < each_blocks_2.length; i += 1) {
                each_blocks_2[i].d(1);
              }

              each_blocks_2.length = each_value_2.length;
            }

            if (dirty[0] & /*taskTypes, newTask*/ 129) {
              each_value_1 = /*taskTypes*/ ctx[7];
              let i;

              for (i = 0; i < each_value_1.length; i += 1) {
                const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

                if (each_blocks_1[i]) {
                  each_blocks_1[i].p(child_ctx, dirty);
                } else {
                  each_blocks_1[i] = create_each_block_1$2(child_ctx);
                  each_blocks_1[i].c();
                  each_blocks_1[i].m(div2, null);
                }
              }

              for (; i < each_blocks_1.length; i += 1) {
                each_blocks_1[i].d(1);
              }

              each_blocks_1.length = each_value_1.length;
            }

            if (dirty[0] & /*newTask, markToDo*/ 4097) {
              each_value = /*newTask*/ ctx[0].todos;
              let i;

              for (i = 0; i < each_value.length; i += 1) {
                const child_ctx = get_each_context$3(ctx, each_value, i);

                if (each_blocks[i]) {
                  each_blocks[i].p(child_ctx, dirty);
                } else {
                  each_blocks[i] = create_each_block$3(child_ctx);
                  each_blocks[i].c();
                  each_blocks[i].m(ul, null);
                }
              }

              for (; i < each_blocks.length; i += 1) {
                each_blocks[i].d(1);
              }

              each_blocks.length = each_value.length;
            }

            if (dirty[0] & /*newTask*/ 1) {
              toggle_class(ul, "hidden", /*newTask*/ ctx[0].todos.length < 1);
            }

            if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block.d(1);
              if_block = current_block_type(ctx);

              if (if_block) {
                if_block.c();
                if_block.m(fieldset5, null);
              }
            }
          },
          i: noop,
          o: noop,
          d(detaching) {
            if (detaching) detach(form);
            /*label0_binding*/ ctx[15](null);
            destroy_each(each_blocks_2, detaching);
            destroy_each(each_blocks_1, detaching);
            destroy_each(each_blocks, detaching);
            if_block.d();
            mounted = false;
            run_all(dispose);
          },
        };
      }

      function instance$7($$self, $$props, $$invalidate) {
        let nameValidated;
        let shortNameValidated;
        let firstField;
        let newTodoText = "";
        crossfade({});
        let taskTypes = ["Project", "Personal", "Drive", "Meeting", "Personal", "Break"];
        let trackForHorizonOptions = [];

        onMount(() => {
          firstField.focus();
        });

        let { newTask = {} } = $$props;
        let showNewToDo = false;
        let newTodoTextField;

        async function showNewToDoFunc() {
          $$invalidate(3, (showNewToDo = true));
          await tick();
          newTodoTextField.focus();
        }

        function addNewTodo() {
          $$invalidate(13, (attempted = true));
          let id = newTask.todos.length + 1;
          let name = newTodoText;
          let completed = false;
          let newTodo = { id, name, completed };
          $$invalidate(0, (newTask.todos = [...newTask.todos, newTodo]), newTask);
          $$invalidate(3, (showNewToDo = false));
          $$invalidate(2, (newTodoText = ""));
        }

        function cancelTodo() {
          $$invalidate(3, (showNewToDo = false));
        }

        new Date().toISOString().substring(0, 10);

        function markToDo(todo) {
          todo.completed = !todo.completed;
          $$invalidate(0, newTask);
        }

        let { attempted = false } = $$props;
        const $$binding_groups = [[], []];

        function submit_handler(event) {
          bubble.call(this, $$self, event);
        }

        function label0_binding($$value) {
          binding_callbacks[$$value ? "unshift" : "push"](() => {
            firstField = $$value;
            $$invalidate(1, firstField);
          });
        }

        function input0_input_handler() {
          newTask.name = this.value;
          $$invalidate(0, newTask);
        }

        function input1_input_handler() {
          newTask.shortname = this.value;
          $$invalidate(0, newTask);
        }

        function input2_input_handler() {
          newTask.duration = to_number(this.value);
          $$invalidate(0, newTask);
        }

        function input_change_handler() {
          newTask.horizonEntry = this.__value;
          $$invalidate(0, newTask);
        }

        function input_change_handler_1() {
          newTask.taskType = this.__value;
          $$invalidate(0, newTask);
        }

        const click_handler = (todo) => markToDo(todo);

        function input_input_handler() {
          newTodoText = this.value;
          $$invalidate(2, newTodoText);
        }

        function input_binding($$value) {
          binding_callbacks[$$value ? "unshift" : "push"](() => {
            newTodoTextField = $$value;
            $$invalidate(4, newTodoTextField);
          });
        }

        $$self.$$set = ($$props) => {
          if ("newTask" in $$props) $$invalidate(0, (newTask = $$props.newTask));
          if ("attempted" in $$props) $$invalidate(13, (attempted = $$props.attempted));
        };

        $$self.$$.update = () => {
          if ($$self.$$.dirty[0] & /*newTask*/ 1) {
            //FORM VALIDATION
            $$invalidate(6, (nameValidated = newTask.name !== ""));
          }

          if ($$self.$$.dirty[0] & /*newTask*/ 1) {
            $$invalidate(5, (shortNameValidated = newTask.shortname !== ""));
          }
        };

        return [
          newTask,
          firstField,
          newTodoText,
          showNewToDo,
          newTodoTextField,
          shortNameValidated,
          nameValidated,
          taskTypes,
          trackForHorizonOptions,
          showNewToDoFunc,
          addNewTodo,
          cancelTodo,
          markToDo,
          attempted,
          submit_handler,
          label0_binding,
          input0_input_handler,
          input1_input_handler,
          input2_input_handler,
          input_change_handler,
          $$binding_groups,
          input_change_handler_1,
          click_handler,
          input_input_handler,
          input_binding,
        ];
      }

      class TaskForm extends SvelteComponent {
        constructor(options) {
          super();
          init(this, options, instance$7, create_fragment$6, safe_not_equal, { newTask: 0, attempted: 13 }, null, [-1, -1]);
        }
      }

      var NewTask_svelte_svelte_type_style_lang = "";

      /* src/NewTask.svelte generated by Svelte v3.46.4 */

      function create_fragment$5(ctx) {
        let div1;
        let taskform;
        let t0;
        let div0;
        let button0;
        let t2;
        let button1;
        let div1_intro;
        let current;
        let mounted;
        let dispose;

        taskform = new TaskForm({
          props: {
            newTask: /*newTask*/ ctx[1],
            attempted: /*attempted*/ ctx[0],
          },
        });

        return {
          c() {
            div1 = element("div");
            create_component(taskform.$$.fragment);
            t0 = space();
            div0 = element("div");
            button0 = element("button");
            button0.textContent = "Cancel";
            t2 = space();
            button1 = element("button");
            button1.textContent = "Add task";
            attr(button0, "class", "cancelTask svelte-1bgw4dc");
            attr(button0, "type", "submit");
            attr(button1, "class", "addTask");
            attr(button1, "type", "submit");
            attr(div0, "class", "buttonWrapper svelte-1bgw4dc");
            attr(div1, "class", "newTaskContainer svelte-1bgw4dc");
          },
          m(target, anchor) {
            insert(target, div1, anchor);
            mount_component(taskform, div1, null);
            append(div1, t0);
            append(div1, div0);
            append(div0, button0);
            append(div0, t2);
            append(div0, button1);
            current = true;

            if (!mounted) {
              dispose = [listen(button0, "click", /*dispatchCancel*/ ctx[3]), listen(button1, "click", /*dispatchSubmit*/ ctx[2])];

              mounted = true;
            }
          },
          p(ctx, [dirty]) {
            const taskform_changes = {};
            if (dirty & /*attempted*/ 1) taskform_changes.attempted = /*attempted*/ ctx[0];
            taskform.$set(taskform_changes);
          },
          i(local) {
            if (current) return;
            transition_in(taskform.$$.fragment, local);

            if (!div1_intro) {
              add_render_callback(() => {
                div1_intro = create_in_transition(div1, slide, {});
                div1_intro.start();
              });
            }

            current = true;
          },
          o(local) {
            transition_out(taskform.$$.fragment, local);
            current = false;
          },
          d(detaching) {
            if (detaching) detach(div1);
            destroy_component(taskform);
            mounted = false;
            run_all(dispose);
          },
        };
      }

      function instance$6($$self, $$props, $$invalidate) {
        let dispatch = createEventDispatcher();

        let newTask = {
          id: undefined,
          name: "",
          shortname: "",
          taskType: "Project",
          completed: false,
          duration: 1,
          elapsed: 0,
          active: false,
          pressed: false,
          dueDate: undefined,
          todos: [],
          laps: [],
          horizonEntry: "Yes",
          newTodo: false,
        };

        // $: console.log(newTask);
        let attempted = false;

        function dispatchSubmit() {
          $$invalidate(0, (attempted = true));
          dispatch("addtask", newTask);
        }

        function dispatchCancel() {
          dispatch("cancel");
        }

        return [attempted, newTask, dispatchSubmit, dispatchCancel];
      }

      class NewTask extends SvelteComponent {
        constructor(options) {
          super();
          init(this, options, instance$6, create_fragment$5, safe_not_equal, {});
        }
      }

      var TaskModal_svelte_svelte_type_style_lang = "";

      /* src/TaskModal.svelte generated by Svelte v3.46.4 */

      function create_fragment$4(ctx) {
        let div1;
        let taskform;
        let t0;
        let div0;
        let button0;
        let t2;
        let button1;
        let t4;
        let button2;
        let div1_intro;
        let current;
        let mounted;
        let dispose;

        taskform = new TaskForm({
          props: {
            newTask: /*newTask*/ ctx[0],
            attempted: /*attempted*/ ctx[1],
          },
        });

        return {
          c() {
            div1 = element("div");
            create_component(taskform.$$.fragment);
            t0 = space();
            div0 = element("div");
            button0 = element("button");
            button0.textContent = "Done";
            t2 = space();
            button1 = element("button");
            button1.textContent = "Complete task";
            t4 = space();
            button2 = element("button");
            button2.textContent = "Delete task";
            attr(button0, "class", "cancelTask");
            attr(button0, "type", "submit");
            attr(button1, "class", "deleteTask svelte-1hoasx3");
            attr(button1, "type", "submit");
            attr(button2, "class", "deleteTask svelte-1hoasx3");
            attr(button2, "type", "submit");
            attr(div0, "class", "buttonWrapper svelte-1hoasx3");
            attr(div1, "class", "newTaskContainer svelte-1hoasx3");
          },
          m(target, anchor) {
            insert(target, div1, anchor);
            mount_component(taskform, div1, null);
            append(div1, t0);
            append(div1, div0);
            append(div0, button0);
            append(div0, t2);
            append(div0, button1);
            append(div0, t4);
            append(div0, button2);
            current = true;

            if (!mounted) {
              dispose = [listen(button0, "click", /*dispatchSubmit*/ ctx[2]), listen(button1, "click", /*dispatchComplete*/ ctx[4]), listen(button2, "click", /*dispatchDelete*/ ctx[3])];

              mounted = true;
            }
          },
          p(ctx, [dirty]) {
            const taskform_changes = {};
            if (dirty & /*newTask*/ 1) taskform_changes.newTask = /*newTask*/ ctx[0];
            if (dirty & /*attempted*/ 2) taskform_changes.attempted = /*attempted*/ ctx[1];
            taskform.$set(taskform_changes);
          },
          i(local) {
            if (current) return;
            transition_in(taskform.$$.fragment, local);

            if (!div1_intro) {
              add_render_callback(() => {
                div1_intro = create_in_transition(div1, slide, {});
                div1_intro.start();
              });
            }

            current = true;
          },
          o(local) {
            transition_out(taskform.$$.fragment, local);
            current = false;
          },
          d(detaching) {
            if (detaching) detach(div1);
            destroy_component(taskform);
            mounted = false;
            run_all(dispose);
          },
        };
      }

      function instance$5($$self, $$props, $$invalidate) {
        let dispatch = createEventDispatcher();

        function dispatchSubmit() {
          $$invalidate(1, (attempted = true));
          dispatch("updatetask", newTask);
        } // let duration = new Date(newTask.dueDate) - new Date();

        function dispatchDelete(e) {
          let confirmation = confirm("Are you sure you want to delete this task?");

          if (confirmation) {
            dispatch("deletetask", newTask);
          }
        }

        function dispatchComplete(e) {
          dispatch("completetask", newTask);
        }

        let { newTask } = $$props;
        let attempted = false;

        $$self.$$set = ($$props) => {
          if ("newTask" in $$props) $$invalidate(0, (newTask = $$props.newTask));
        };

        return [newTask, attempted, dispatchSubmit, dispatchDelete, dispatchComplete];
      }

      class TaskModal extends SvelteComponent {
        constructor(options) {
          super();
          init(this, options, instance$5, create_fragment$4, safe_not_equal, { newTask: 0 });
        }
      }

      // utility functions used in the project

      // a and b are javascript Date objects
      function dateDiffInDays(a, b) {
        // Discard the time and time-zone information.
        const utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
        const utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());

        const _MS_PER_DAY = 1000 * 60 * 60 * 24;
        return Math.floor((utc2 - utc1) / _MS_PER_DAY);
      }

      // test it
      const a = new Date("2017-01-01"),
        b = new Date("2017-07-25");
      dateDiffInDays(a, b);

      var Stopwatch_svelte_svelte_type_style_lang = "";

      var Laps_svelte_svelte_type_style_lang = "";

      var Controls_svelte_svelte_type_style_lang = "";

      // set up a readable store which returns the number of milliseconds between the moment the store is subscribed and following an interval
      const time = readable(0, function start(set) {
        const beginning = new Date();
        const beginningTime = beginning.getTime();

        const interval = setInterval(() => {
          const current = new Date();
          const currentTime = current.getTime();
          set(currentTime - beginningTime);
        }, 10);

        return function stop() {
          // ! forcedly set the readable value to 0 before clearing the interval
          // it seems the store would otherwise retain the last value and the application would stagger from this value straight to 0
          set(0);
          clearInterval(interval);
        };
      });

      var Watch_svelte_svelte_type_style_lang = "";

      /* src/Watch.svelte generated by Svelte v3.46.4 */

      function instance$4($$self, $$props, $$invalidate) {
        let { lapse = 0 } = $$props;

        // previous is set to record the time accumulated before the pause button is pressed
        let previous = 0;

        // unsubscribe is set to refer to the function used to unsubscribe from the store
        let unsubscribe;

        // through the start function pair the lapse variable to the time retrieved from the readable store
        function start() {
          // assign the stop function to unsubscribe
          $$invalidate(
            3,
            (unsubscribe = time.subscribe((value) => {
              // add the previous value to the current number of milliseconds
              $$invalidate(0, (lapse = value + previous));
            }))
          );
        }

        onMount(() => {
          // start the stopwatch
          start();
        });

        // through the terminate function unsubscribe from the readable store
        function terminate() {
          // check if unsubscribe is truthy (this to cover the situation in which the stop button is pressed after the pause button)
          if (unsubscribe) {
            unsubscribe();
            $$invalidate(3, (unsubscribe = null));
          }
        }

        // through the pause function unsubscribe from the store and set previous to match the value held by lapse
        function pause() {
          previous = lapse;
          terminate();
        } // lap();

        let { laps = [] } = $$props;

        // unsubscribe from the store to avoid memory leaks
        onDestroy(() => {
          terminate();
        });

        let { paused = false } = $$props;

        $$self.$$set = ($$props) => {
          if ("lapse" in $$props) $$invalidate(0, (lapse = $$props.lapse));
          if ("laps" in $$props) $$invalidate(1, (laps = $$props.laps));
          if ("paused" in $$props) $$invalidate(2, (paused = $$props.paused));
        };

        $$self.$$.update = () => {
          if ($$self.$$.dirty & /*unsubscribe*/ 8);

          if ($$self.$$.dirty & /*lapse*/ 1);

          if ($$self.$$.dirty & /*paused*/ 4) {
            if (paused === true) pause();
          }
        };

        return [lapse, laps, paused, unsubscribe];
      }

      class Watch extends SvelteComponent {
        constructor(options) {
          super();
          init(this, options, instance$4, null, safe_not_equal, { lapse: 0, laps: 1, paused: 2 });
        }
      }

      var Report_svelte_svelte_type_style_lang = "";

      /* src/Report.svelte generated by Svelte v3.46.4 */

      function get_each_context$2(ctx, list, i) {
        const child_ctx = ctx.slice();
        child_ctx[3] = list[i];
        return child_ctx;
      }

      // (19:2) {#each tasks as task}
      function create_each_block$2(ctx) {
        let div4;
        let div0;
        let t0_value = /*task*/ ctx[3].name + "";
        let t0;
        let t1;
        let div1;
        let t2_value = /*task*/ (ctx[3].elapsed / 1000 / 60).toFixed(0) + "";
        let t2;
        let t3;
        let t4;
        let div2;
        let t5_value = /*task*/ ctx[3].duration * 60 + "";
        let t5;
        let t6;
        let t7;
        let div3;
        let t8_value = /*task*/ ctx[3].laps.length + "";
        let t8;

        return {
          c() {
            div4 = element("div");
            div0 = element("div");
            t0 = text(t0_value);
            t1 = space();
            div1 = element("div");
            t2 = text(t2_value);
            t3 = text(" mins");
            t4 = space();
            div2 = element("div");
            t5 = text(t5_value);
            t6 = text(" mins");
            t7 = space();
            div3 = element("div");
            t8 = text(t8_value);
            attr(div0, "class", "taskName");
            attr(div1, "class", "taskTime svelte-n6f8vf");
            attr(div2, "class", "taskTime svelte-n6f8vf");
            attr(div3, "class", "taskTime svelte-n6f8vf");
            attr(div4, "class", "task svelte-n6f8vf");
          },
          m(target, anchor) {
            insert(target, div4, anchor);
            append(div4, div0);
            append(div0, t0);
            append(div4, t1);
            append(div4, div1);
            append(div1, t2);
            append(div1, t3);
            append(div4, t4);
            append(div4, div2);
            append(div2, t5);
            append(div2, t6);
            append(div4, t7);
            append(div4, div3);
            append(div3, t8);
          },
          p(ctx, dirty) {
            if (dirty & /*tasks*/ 1 && t0_value !== (t0_value = /*task*/ ctx[3].name + "")) set_data(t0, t0_value);
            if (dirty & /*tasks*/ 1 && t2_value !== (t2_value = /*task*/ (ctx[3].elapsed / 1000 / 60).toFixed(0) + "")) set_data(t2, t2_value);
            if (dirty & /*tasks*/ 1 && t5_value !== (t5_value = /*task*/ ctx[3].duration * 60 + "")) set_data(t5, t5_value);
            if (dirty & /*tasks*/ 1 && t8_value !== (t8_value = /*task*/ ctx[3].laps.length + "")) set_data(t8, t8_value);
          },
          d(detaching) {
            if (detaching) detach(div4);
          },
        };
      }

      function create_fragment$3(ctx) {
        let div5;
        let div4;
        let t7;
        let t8;
        let button;
        let mounted;
        let dispose;
        let each_value = /*tasks*/ ctx[0];
        let each_blocks = [];

        for (let i = 0; i < each_value.length; i += 1) {
          each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
        }

        return {
          c() {
            div5 = element("div");
            div4 = element("div");

            div4.innerHTML = `<div class="taskName">Task name</div> 
    <div class="taskTime svelte-n6f8vf">Total duration</div> 
    <div class="taskTime svelte-n6f8vf">Planned duration</div> 
    <div class="taskTime svelte-n6f8vf">No. of laps</div>`;

            t7 = space();

            for (let i = 0; i < each_blocks.length; i += 1) {
              each_blocks[i].c();
            }

            t8 = space();
            button = element("button");
            button.textContent = "Back";
            attr(div4, "class", "task header svelte-n6f8vf");
            attr(button, "class", "closeReport svelte-n6f8vf");
            attr(div5, "class", "reportContainer svelte-n6f8vf");
          },
          m(target, anchor) {
            insert(target, div5, anchor);
            append(div5, div4);
            append(div5, t7);

            for (let i = 0; i < each_blocks.length; i += 1) {
              each_blocks[i].m(div5, null);
            }

            append(div5, t8);
            append(div5, button);

            if (!mounted) {
              dispose = listen(button, "click", /*dispatchClose*/ ctx[1]);
              mounted = true;
            }
          },
          p(ctx, [dirty]) {
            if (dirty & /*tasks*/ 1) {
              each_value = /*tasks*/ ctx[0];
              let i;

              for (i = 0; i < each_value.length; i += 1) {
                const child_ctx = get_each_context$2(ctx, each_value, i);

                if (each_blocks[i]) {
                  each_blocks[i].p(child_ctx, dirty);
                } else {
                  each_blocks[i] = create_each_block$2(child_ctx);
                  each_blocks[i].c();
                  each_blocks[i].m(div5, t8);
                }
              }

              for (; i < each_blocks.length; i += 1) {
                each_blocks[i].d(1);
              }

              each_blocks.length = each_value.length;
            }
          },
          i: noop,
          o: noop,
          d(detaching) {
            if (detaching) detach(div5);
            destroy_each(each_blocks, detaching);
            mounted = false;
            dispose();
          },
        };
      }

      function instance$3($$self, $$props, $$invalidate) {
        let { tasks = [] } = $$props;
        let dispatch = createEventDispatcher();

        function dispatchClose() {
          dispatch("close");
        }

        $$self.$$set = ($$props) => {
          if ("tasks" in $$props) $$invalidate(0, (tasks = $$props.tasks));
        };

        return [tasks, dispatchClose];
      }

      class Report extends SvelteComponent {
        constructor(options) {
          super();
          init(this, options, instance$3, create_fragment$3, safe_not_equal, { tasks: 0 });
        }
      }

      var CompletedTasks_svelte_svelte_type_style_lang = "";

      /* src/CompletedTasks.svelte generated by Svelte v3.46.4 */

      function get_each_context$1(ctx, list, i) {
        const child_ctx = ctx.slice();
        child_ctx[9] = list[i];
        return child_ctx;
      }

      function get_each_context_1$1(ctx, list, i) {
        const child_ctx = ctx.slice();
        child_ctx[9] = list[i];
        return child_ctx;
      }

      // (30:2) {#each incompleteTasks as task (task.id)}
      function create_each_block_1$1(key_1, ctx) {
        let div5;
        let div0;
        let t0_value = /*task*/ ctx[9].name + "";
        let t0;
        let t1;
        let div1;
        let t2_value = /*task*/ (ctx[9].elapsed / 1000 / 60).toFixed(0) + "";
        let t2;
        let t3;
        let t4;
        let div2;
        let t5_value = /*task*/ ctx[9].duration * 60 + "";
        let t5;
        let t6;
        let t7;
        let div3;
        let t8_value = /*task*/ ctx[9].laps.length + "";
        let t8;
        let t9;
        let div4;
        let div5_intro;
        let div5_outro;
        let current;
        let mounted;
        let dispose;

        function click_handler() {
          return /*click_handler*/ ctx[6](/*task*/ ctx[9]);
        }

        return {
          key: key_1,
          first: null,
          c() {
            div5 = element("div");
            div0 = element("div");
            t0 = text(t0_value);
            t1 = space();
            div1 = element("div");
            t2 = text(t2_value);
            t3 = text(" mins");
            t4 = space();
            div2 = element("div");
            t5 = text(t5_value);
            t6 = text(" mins");
            t7 = space();
            div3 = element("div");
            t8 = text(t8_value);
            t9 = space();
            div4 = element("div");
            div4.textContent = "In progress";
            attr(div0, "class", "taskName");
            attr(div1, "class", "taskTime svelte-1747s49");
            attr(div2, "class", "taskTime svelte-1747s49");
            attr(div3, "class", "taskTime svelte-1747s49");
            attr(div4, "class", "statusChange incomplete svelte-1747s49");
            attr(div5, "class", "task svelte-1747s49");
            this.first = div5;
          },
          m(target, anchor) {
            insert(target, div5, anchor);
            append(div5, div0);
            append(div0, t0);
            append(div5, t1);
            append(div5, div1);
            append(div1, t2);
            append(div1, t3);
            append(div5, t4);
            append(div5, div2);
            append(div2, t5);
            append(div2, t6);
            append(div5, t7);
            append(div5, div3);
            append(div3, t8);
            append(div5, t9);
            append(div5, div4);
            current = true;

            if (!mounted) {
              dispose = listen(div4, "click", click_handler);
              mounted = true;
            }
          },
          p(new_ctx, dirty) {
            ctx = new_ctx;
            if ((!current || dirty & /*incompleteTasks*/ 2) && t0_value !== (t0_value = /*task*/ ctx[9].name + "")) set_data(t0, t0_value);
            if ((!current || dirty & /*incompleteTasks*/ 2) && t2_value !== (t2_value = /*task*/ (ctx[9].elapsed / 1000 / 60).toFixed(0) + "")) set_data(t2, t2_value);
            if ((!current || dirty & /*incompleteTasks*/ 2) && t5_value !== (t5_value = /*task*/ ctx[9].duration * 60 + "")) set_data(t5, t5_value);
            if ((!current || dirty & /*incompleteTasks*/ 2) && t8_value !== (t8_value = /*task*/ ctx[9].laps.length + "")) set_data(t8, t8_value);
          },
          i(local) {
            if (current) return;

            add_render_callback(() => {
              if (div5_outro) div5_outro.end(1);
              div5_intro = create_in_transition(div5, /*receive*/ ctx[5], { key: /*task*/ ctx[9].id, duration: 500 });
              div5_intro.start();
            });

            current = true;
          },
          o(local) {
            if (div5_intro) div5_intro.invalidate();
            div5_outro = create_out_transition(div5, /*send*/ ctx[4], { key: /*task*/ ctx[9].id, duration: 500 });
            current = false;
          },
          d(detaching) {
            if (detaching) detach(div5);
            if (detaching && div5_outro) div5_outro.end();
            mounted = false;
            dispose();
          },
        };
      }

      // (48:2) {#each completedTasks as task (task.id)}
      function create_each_block$1(key_1, ctx) {
        let div5;
        let div0;
        let t0_value = /*task*/ ctx[9].name + "";
        let t0;
        let t1;
        let div1;
        let t2_value = /*task*/ (ctx[9].elapsed / 1000 / 60).toFixed(0) + "";
        let t2;
        let t3;
        let t4;
        let div2;
        let t5_value = /*task*/ ctx[9].duration * 60 + "";
        let t5;
        let t6;
        let t7;
        let div3;
        let t8_value = /*task*/ ctx[9].laps.length + "";
        let t8;
        let t9;
        let div4;
        let div5_intro;
        let div5_outro;
        let current;
        let mounted;
        let dispose;

        function click_handler_1() {
          return /*click_handler_1*/ ctx[7](/*task*/ ctx[9]);
        }

        return {
          key: key_1,
          first: null,
          c() {
            div5 = element("div");
            div0 = element("div");
            t0 = text(t0_value);
            t1 = space();
            div1 = element("div");
            t2 = text(t2_value);
            t3 = text(" mins");
            t4 = space();
            div2 = element("div");
            t5 = text(t5_value);
            t6 = text(" mins");
            t7 = space();
            div3 = element("div");
            t8 = text(t8_value);
            t9 = space();
            div4 = element("div");
            div4.textContent = "Completed";
            attr(div0, "class", "taskName");
            attr(div1, "class", "taskTime svelte-1747s49");
            attr(div2, "class", "taskTime svelte-1747s49");
            attr(div3, "class", "taskTime svelte-1747s49");
            attr(div4, "class", "statusChange svelte-1747s49");
            attr(div5, "class", "task svelte-1747s49");
            this.first = div5;
          },
          m(target, anchor) {
            insert(target, div5, anchor);
            append(div5, div0);
            append(div0, t0);
            append(div5, t1);
            append(div5, div1);
            append(div1, t2);
            append(div1, t3);
            append(div5, t4);
            append(div5, div2);
            append(div2, t5);
            append(div2, t6);
            append(div5, t7);
            append(div5, div3);
            append(div3, t8);
            append(div5, t9);
            append(div5, div4);
            current = true;

            if (!mounted) {
              dispose = listen(div4, "click", click_handler_1);
              mounted = true;
            }
          },
          p(new_ctx, dirty) {
            ctx = new_ctx;
            if ((!current || dirty & /*completedTasks*/ 1) && t0_value !== (t0_value = /*task*/ ctx[9].name + "")) set_data(t0, t0_value);
            if ((!current || dirty & /*completedTasks*/ 1) && t2_value !== (t2_value = /*task*/ (ctx[9].elapsed / 1000 / 60).toFixed(0) + "")) set_data(t2, t2_value);
            if ((!current || dirty & /*completedTasks*/ 1) && t5_value !== (t5_value = /*task*/ ctx[9].duration * 60 + "")) set_data(t5, t5_value);
            if ((!current || dirty & /*completedTasks*/ 1) && t8_value !== (t8_value = /*task*/ ctx[9].laps.length + "")) set_data(t8, t8_value);
          },
          i(local) {
            if (current) return;

            add_render_callback(() => {
              if (div5_outro) div5_outro.end(1);
              div5_intro = create_in_transition(div5, /*receive*/ ctx[5], { key: /*task*/ ctx[9].id, duration: 500 });
              div5_intro.start();
            });

            current = true;
          },
          o(local) {
            if (div5_intro) div5_intro.invalidate();
            div5_outro = create_out_transition(div5, /*send*/ ctx[4], { key: /*task*/ ctx[9].id, duration: 500 });
            current = false;
          },
          d(detaching) {
            if (detaching) detach(div5);
            if (detaching && div5_outro) div5_outro.end();
            mounted = false;
            dispose();
          },
        };
      }

      function create_fragment$2(ctx) {
        let div8;
        let h2;
        let t1;
        let div5;
        let t11;
        let div6;
        let t13;
        let each_blocks_1 = [];
        let each0_lookup = new Map();
        let t14;
        let div7;
        let t16;
        let each_blocks = [];
        let each1_lookup = new Map();
        let t17;
        let button;
        let div8_intro;
        let current;
        let mounted;
        let dispose;
        let each_value_1 = /*incompleteTasks*/ ctx[1];
        const get_key = (ctx) => /*task*/ ctx[9].id;

        for (let i = 0; i < each_value_1.length; i += 1) {
          let child_ctx = get_each_context_1$1(ctx, each_value_1, i);
          let key = get_key(child_ctx);
          each0_lookup.set(key, (each_blocks_1[i] = create_each_block_1$1(key, child_ctx)));
        }

        let each_value = /*completedTasks*/ ctx[0];
        const get_key_1 = (ctx) => /*task*/ ctx[9].id;

        for (let i = 0; i < each_value.length; i += 1) {
          let child_ctx = get_each_context$1(ctx, each_value, i);
          let key = get_key_1(child_ctx);
          each1_lookup.set(key, (each_blocks[i] = create_each_block$1(key, child_ctx)));
        }

        return {
          c() {
            div8 = element("div");
            h2 = element("h2");
            h2.textContent = "Summary";
            t1 = space();
            div5 = element("div");

            div5.innerHTML = `<div class="taskName">Task name</div> 
    <div class="taskTime svelte-1747s49">Total duration</div> 
    <div class="taskTime svelte-1747s49">Planned duration</div> 
    <div class="taskTime svelte-1747s49">No. of laps</div> 
    <div class="taskTime svelte-1747s49">Status</div>`;

            t11 = space();
            div6 = element("div");
            div6.textContent = "In progress";
            t13 = space();

            for (let i = 0; i < each_blocks_1.length; i += 1) {
              each_blocks_1[i].c();
            }

            t14 = space();
            div7 = element("div");
            div7.textContent = "Completed";
            t16 = space();

            for (let i = 0; i < each_blocks.length; i += 1) {
              each_blocks[i].c();
            }

            t17 = space();
            button = element("button");
            button.textContent = "Back";
            attr(h2, "class", "svelte-1747s49");
            attr(div5, "class", "task header svelte-1747s49");
            attr(div6, "class", "task header subheader svelte-1747s49");
            attr(div7, "class", "task header subheader svelte-1747s49");
            attr(button, "class", "closeReport svelte-1747s49");
            attr(div8, "class", "container svelte-1747s49");
          },
          m(target, anchor) {
            insert(target, div8, anchor);
            append(div8, h2);
            append(div8, t1);
            append(div8, div5);
            append(div8, t11);
            append(div8, div6);
            append(div8, t13);

            for (let i = 0; i < each_blocks_1.length; i += 1) {
              each_blocks_1[i].m(div8, null);
            }

            append(div8, t14);
            append(div8, div7);
            append(div8, t16);

            for (let i = 0; i < each_blocks.length; i += 1) {
              each_blocks[i].m(div8, null);
            }

            append(div8, t17);
            append(div8, button);
            current = true;

            if (!mounted) {
              dispose = listen(button, "click", /*dispatchClose*/ ctx[3]);
              mounted = true;
            }
          },
          p(ctx, [dirty]) {
            if (dirty & /*incompleteTasks, dispatchStatusChange*/ 6) {
              each_value_1 = /*incompleteTasks*/ ctx[1];
              group_outros();
              each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx, each_value_1, each0_lookup, div8, outro_and_destroy_block, create_each_block_1$1, t14, get_each_context_1$1);
              check_outros();
            }

            if (dirty & /*completedTasks, dispatchStatusChange*/ 5) {
              each_value = /*completedTasks*/ ctx[0];
              group_outros();
              each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx, each_value, each1_lookup, div8, outro_and_destroy_block, create_each_block$1, t17, get_each_context$1);
              check_outros();
            }
          },
          i(local) {
            if (current) return;

            for (let i = 0; i < each_value_1.length; i += 1) {
              transition_in(each_blocks_1[i]);
            }

            for (let i = 0; i < each_value.length; i += 1) {
              transition_in(each_blocks[i]);
            }

            if (!div8_intro) {
              add_render_callback(() => {
                div8_intro = create_in_transition(div8, slide, {});
                div8_intro.start();
              });
            }

            current = true;
          },
          o(local) {
            for (let i = 0; i < each_blocks_1.length; i += 1) {
              transition_out(each_blocks_1[i]);
            }

            for (let i = 0; i < each_blocks.length; i += 1) {
              transition_out(each_blocks[i]);
            }

            current = false;
          },
          d(detaching) {
            if (detaching) detach(div8);

            for (let i = 0; i < each_blocks_1.length; i += 1) {
              each_blocks_1[i].d();
            }

            for (let i = 0; i < each_blocks.length; i += 1) {
              each_blocks[i].d();
            }

            mounted = false;
            dispose();
          },
        };
      }

      function instance$2($$self, $$props, $$invalidate) {
        let dispatch = createEventDispatcher();
        let { completedTasks = [] } = $$props;
        let { incompleteTasks = [] } = $$props;

        function dispatchStatusChange(task) {
          dispatch("markstatus", task);
        }

        function dispatchClose() {
          dispatch("close");
        }

        const [send, receive] = crossfade({});
        const click_handler = (task) => dispatchStatusChange(task);
        const click_handler_1 = (task) => dispatchStatusChange(task);

        $$self.$$set = ($$props) => {
          if ("completedTasks" in $$props) $$invalidate(0, (completedTasks = $$props.completedTasks));
          if ("incompleteTasks" in $$props) $$invalidate(1, (incompleteTasks = $$props.incompleteTasks));
        };

        return [completedTasks, incompleteTasks, dispatchStatusChange, dispatchClose, send, receive, click_handler, click_handler_1];
      }

      class CompletedTasks extends SvelteComponent {
        constructor(options) {
          super();
          init(this, options, instance$2, create_fragment$2, safe_not_equal, { completedTasks: 0, incompleteTasks: 1 });
        }
      }

      var Main_svelte_svelte_type_style_lang = "";

      /* src/Main.svelte generated by Svelte v3.46.4 */

      const { document: document_1 } = globals;

      function get_each_context(ctx, list, i) {
        const child_ctx = ctx.slice();
        child_ctx[67] = list[i];
        child_ctx[68] = list;
        child_ctx[69] = i;
        return child_ctx;
      }

      function get_each_context_1(ctx, list, i) {
        const child_ctx = ctx.slice();
        child_ctx[67] = list[i];
        child_ctx[70] = list;
        child_ctx[71] = i;
        return child_ctx;
      }

      function get_each_context_2(ctx, list, i) {
        const child_ctx = ctx.slice();
        child_ctx[72] = list[i];
        return child_ctx;
      }

      function get_each_context_3(ctx, list, i) {
        const child_ctx = ctx.slice();
        child_ctx[72] = list[i];
        return child_ctx;
      }

      function get_each_context_4(ctx, list, i) {
        const child_ctx = ctx.slice();
        child_ctx[67] = list[i];
        child_ctx[71] = i;
        return child_ctx;
      }

      // (375:0) {#if showNewTask === true}
      function create_if_block_7(ctx) {
        let div;
        let newtask;
        let current;
        newtask = new NewTask({});
        newtask.$on("addtask", /*addTask*/ ctx[19]);
        newtask.$on("cancel", /*cancelAddTask*/ ctx[20]);

        return {
          c() {
            div = element("div");
            create_component(newtask.$$.fragment);
            attr(div, "class", "newTask svelte-1wz5uuo");
          },
          m(target, anchor) {
            insert(target, div, anchor);
            mount_component(newtask, div, null);
            current = true;
          },
          p: noop,
          i(local) {
            if (current) return;
            transition_in(newtask.$$.fragment, local);
            current = true;
          },
          o(local) {
            transition_out(newtask.$$.fragment, local);
            current = false;
          },
          d(detaching) {
            if (detaching) detach(div);
            destroy_component(newtask);
          },
        };
      }

      // (382:2) {#if $tasks.length > 0}
      function create_if_block_6(ctx) {
        let button0;
        let t1;
        let button1;
        let mounted;
        let dispose;

        return {
          c() {
            button0 = element("button");
            button0.innerHTML = `<span>Summary</span>`;
            t1 = space();
            button1 = element("button");
            // button1.textContent = "Horizon export";
            // attr(button0, "class", "tButton");
            // attr(button1, "class", "tButton");
          },
          m(target, anchor) {
            insert(target, button0, anchor);
            insert(target, t1, anchor);
            insert(target, button1, anchor);

            if (!mounted) {
              dispose = [listen(button0, "click", /*click_handler_1*/ ctx[31]), listen(button1, "click", /*copyHorizonCode*/ ctx[21])];

              mounted = true;
            }
          },
          p: noop,
          d(detaching) {
            if (detaching) detach(button0);
            if (detaching) detach(t1);
            if (detaching) detach(button1);
            mounted = false;
            run_all(dispose);
          },
        };
      }

      // (389:0) {#if incompleteTasks.length > 0}
      function create_if_block_3$1(ctx) {
        let div2;
        let div1;
        let div0;
        let each_blocks_1 = [];
        let each0_lookup = new Map();
        let t0;
        let current_block_type_index;
        let if_block;
        let reportWidth_action;
        let t1;
        let each_blocks = [];
        let each1_lookup = new Map();
        let each1_anchor;
        let current;
        let mounted;
        let dispose;
        let each_value_4 = /*incompleteTasks*/ ctx[2];
        const get_key = (ctx) => /*task*/ ctx[67].id;

        for (let i = 0; i < each_value_4.length; i += 1) {
          let child_ctx = get_each_context_4(ctx, each_value_4, i);
          let key = get_key(child_ctx);
          each0_lookup.set(key, (each_blocks_1[i] = create_each_block_4(key, child_ctx)));
        }

        const if_block_creators = [create_if_block_4, create_else_block];
        const if_blocks = [];

        function select_block_type(ctx, dirty) {
          if (/*showTaskModal*/ ctx[1] === false) return 0;
          return 1;
        }

        current_block_type_index = select_block_type(ctx);
        if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
        let each_value = /*incompleteTasks*/ ctx[2].filter(func_2);
        const get_key_1 = (ctx) => /*task*/ ctx[67].id;

        for (let i = 0; i < each_value.length; i += 1) {
          let child_ctx = get_each_context(ctx, each_value, i);
          let key = get_key_1(child_ctx);
          each1_lookup.set(key, (each_blocks[i] = create_each_block(key, child_ctx)));
        }

        return {
          c() {
            div2 = element("div");
            div1 = element("div");
            div0 = element("div");

            for (let i = 0; i < each_blocks_1.length; i += 1) {
              each_blocks_1[i].c();
            }

            t0 = space();
            if_block.c();
            t1 = space();

            for (let i = 0; i < each_blocks.length; i += 1) {
              each_blocks[i].c();
            }

            each1_anchor = empty();
            attr(div0, "class", "keyContainer svelte-1wz5uuo");
            attr(div1, "class", "taskBorder svelte-1wz5uuo");
            attr(div2, "class", "taskContainer svelte-1wz5uuo");
            set_style(div2, "--gridTemplateColums", /*gridTemplateColums*/ ctx[11]);
            set_style(div2, "--gridTemplateRowsPercent", /*gridTemplateRowsPercent*/ ctx[3] + "%");
            set_style(div2, "--keyContainerHeight", /*keyContainerHeight*/ ctx[10] + "rem");
          },
          m(target, anchor) {
            insert(target, div2, anchor);
            append(div2, div1);
            append(div1, div0);

            for (let i = 0; i < each_blocks_1.length; i += 1) {
              each_blocks_1[i].m(div0, null);
            }

            append(div2, t0);
            if_blocks[current_block_type_index].m(div2, null);
            insert(target, t1, anchor);

            for (let i = 0; i < each_blocks.length; i += 1) {
              each_blocks[i].m(target, anchor);
            }

            insert(target, each1_anchor, anchor);
            current = true;

            if (!mounted) {
              dispose = action_destroyer((reportWidth_action = /*reportWidth*/ ctx[18].call(null, div2, /*incompleteTasks*/ ctx[2].length)));
              mounted = true;
            }
          },
          p(ctx, dirty) {
            if (dirty[0] & /*incompleteTasks, handleMouseDown, handleMouseUp*/ 196612) {
              each_value_4 = /*incompleteTasks*/ ctx[2];
              each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx, each_value_4, each0_lookup, div0, destroy_block, create_each_block_4, null, get_each_context_4);
            }

            let previous_block_index = current_block_type_index;
            current_block_type_index = select_block_type(ctx);

            if (current_block_type_index === previous_block_index) {
              if_blocks[current_block_type_index].p(ctx, dirty);
            } else {
              group_outros();

              transition_out(if_blocks[previous_block_index], 1, 1, () => {
                if_blocks[previous_block_index] = null;
              });

              check_outros();
              if_block = if_blocks[current_block_type_index];

              if (!if_block) {
                if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
                if_block.c();
              } else {
                if_block.p(ctx, dirty);
              }

              transition_in(if_block, 1);
              if_block.m(div2, null);
            }

            if (!current || dirty[0] & /*gridTemplateColums*/ 2048) {
              set_style(div2, "--gridTemplateColums", /*gridTemplateColums*/ ctx[11]);
            }

            if (!current || dirty[0] & /*gridTemplateRowsPercent*/ 8) {
              set_style(div2, "--gridTemplateRowsPercent", /*gridTemplateRowsPercent*/ ctx[3] + "%");
            }

            if (!current || dirty[0] & /*keyContainerHeight*/ 1024) {
              set_style(div2, "--keyContainerHeight", /*keyContainerHeight*/ ctx[10] + "rem");
            }

            if (reportWidth_action && is_function(reportWidth_action.update) && dirty[0] & /*incompleteTasks*/ 4) reportWidth_action.update.call(null, /*incompleteTasks*/ ctx[2].length);

            if (dirty[0] & /*incompleteTasks*/ 4) {
              each_value = /*incompleteTasks*/ ctx[2].filter(func_2);
              group_outros();
              each_blocks = update_keyed_each(
                each_blocks,
                dirty,
                get_key_1,
                1,
                ctx,
                each_value,
                each1_lookup,
                each1_anchor.parentNode,
                outro_and_destroy_block,
                create_each_block,
                each1_anchor,
                get_each_context
              );
              check_outros();
            }
          },
          i(local) {
            if (current) return;
            transition_in(if_block);

            for (let i = 0; i < each_value.length; i += 1) {
              transition_in(each_blocks[i]);
            }

            current = true;
          },
          o(local) {
            transition_out(if_block);

            for (let i = 0; i < each_blocks.length; i += 1) {
              transition_out(each_blocks[i]);
            }

            current = false;
          },
          d(detaching) {
            if (detaching) detach(div2);

            for (let i = 0; i < each_blocks_1.length; i += 1) {
              each_blocks_1[i].d();
            }

            if_blocks[current_block_type_index].d();
            if (detaching) detach(t1);

            for (let i = 0; i < each_blocks.length; i += 1) {
              each_blocks[i].d(detaching);
            }

            if (detaching) detach(each1_anchor);
            mounted = false;
            dispose();
          },
        };
      }

      // (397:8) {#each incompleteTasks as task, idx (task.id)}
      function create_each_block_4(key_1, ctx) {
        let div5;
        let div4;
        let div3;
        let div2;
        let div0;
        let t0_value = /*idx*/ ctx[71] + 1 + "";
        let t0;
        let t1;
        let div1;
        let t2_value = /*task*/ ctx[67].shortname + "";
        let t2;
        let t3;
        let mounted;
        let dispose;

        function mousedown_handler() {
          return /*mousedown_handler*/ ctx[32](/*task*/ ctx[67]);
        }

        function mouseup_handler() {
          return /*mouseup_handler*/ ctx[33](/*task*/ ctx[67]);
        }

        return {
          key: key_1,
          first: null,
          c() {
            div5 = element("div");
            div4 = element("div");
            div3 = element("div");
            div2 = element("div");
            div0 = element("div");
            t0 = text(t0_value);
            t1 = space();
            div1 = element("div");
            t2 = text(t2_value);
            t3 = space();
            attr(div0, "class", "keyTop svelte-1wz5uuo");
            attr(div1, "class", "keyBottom svelte-1wz5uuo");
            attr(div2, "class", "key whiteKey svelte-1wz5uuo");
            toggle_class(div2, "orangeKey", /*task*/ ctx[67].active === true);
            toggle_class(div2, "keyPressed", /*task*/ ctx[67].pressed === true);
            attr(div3, "class", "keyWrapper svelte-1wz5uuo");
            attr(div4, "class", "keyShadow svelte-1wz5uuo");
            attr(div5, "class", "taskWrapper svelte-1wz5uuo");
            toggle_class(div5, "active", /*task*/ ctx[67].active === true);
            this.first = div5;
          },
          m(target, anchor) {
            insert(target, div5, anchor);
            append(div5, div4);
            append(div4, div3);
            append(div3, div2);
            append(div2, div0);
            append(div0, t0);
            append(div2, t1);
            append(div2, div1);
            append(div1, t2);
            append(div5, t3);

            if (!mounted) {
              dispose = [listen(div2, "mousedown", mousedown_handler), listen(div2, "mouseup", mouseup_handler)];

              mounted = true;
            }
          },
          p(new_ctx, dirty) {
            ctx = new_ctx;
            if (dirty[0] & /*incompleteTasks*/ 4 && t0_value !== (t0_value = /*idx*/ ctx[71] + 1 + "")) set_data(t0, t0_value);
            if (dirty[0] & /*incompleteTasks*/ 4 && t2_value !== (t2_value = /*task*/ ctx[67].shortname + "")) set_data(t2, t2_value);

            if (dirty[0] & /*incompleteTasks*/ 4) {
              toggle_class(div2, "orangeKey", /*task*/ ctx[67].active === true);
            }

            if (dirty[0] & /*incompleteTasks*/ 4) {
              toggle_class(div2, "keyPressed", /*task*/ ctx[67].pressed === true);
            }

            if (dirty[0] & /*incompleteTasks*/ 4) {
              toggle_class(div5, "active", /*task*/ ctx[67].active === true);
            }
          },
          d(detaching) {
            if (detaching) detach(div5);
            mounted = false;
            run_all(dispose);
          },
        };
      }

      // (512:4) {:else}
      function create_else_block(ctx) {
        let div;
        let taskmodal;
        let current;
        taskmodal = new TaskModal({ props: { newTask: /*shownTask*/ ctx[8] } });
        taskmodal.$on("updatetask", /*updateTask*/ ctx[23]);
        taskmodal.$on("deletetask", /*deleteTask*/ ctx[24]);
        taskmodal.$on("completetask", /*completeTask*/ ctx[25]);
        taskmodal.$on("cancel", /*cancel_handler*/ ctx[40]);

        return {
          c() {
            div = element("div");
            create_component(taskmodal.$$.fragment);
            attr(div, "class", "taskModal svelte-1wz5uuo");
          },
          m(target, anchor) {
            insert(target, div, anchor);
            mount_component(taskmodal, div, null);
            current = true;
          },
          p(ctx, dirty) {
            const taskmodal_changes = {};
            if (dirty[0] & /*shownTask*/ 256) taskmodal_changes.newTask = /*shownTask*/ ctx[8];
            taskmodal.$set(taskmodal_changes);
          },
          i(local) {
            if (current) return;
            transition_in(taskmodal.$$.fragment, local);
            current = true;
          },
          o(local) {
            transition_out(taskmodal.$$.fragment, local);
            current = false;
          },
          d(detaching) {
            if (detaching) detach(div);
            destroy_component(taskmodal);
          },
        };
      }

      // (420:4) {#if showTaskModal === false}
      function create_if_block_4(ctx) {
        let div;
        let each_blocks = [];
        let each_1_lookup = new Map();
        let current;
        let each_value_1 = /*incompleteTasks*/ ctx[2];
        const get_key = (ctx) => /*task*/ ctx[67].id;

        for (let i = 0; i < each_value_1.length; i += 1) {
          let child_ctx = get_each_context_1(ctx, each_value_1, i);
          let key = get_key(child_ctx);
          each_1_lookup.set(key, (each_blocks[i] = create_each_block_1(key, child_ctx)));
        }

        return {
          c() {
            div = element("div");

            for (let i = 0; i < each_blocks.length; i += 1) {
              each_blocks[i].c();
            }

            attr(div, "class", "keyContainer details svelte-1wz5uuo");
            set_style(div, "width", /*keyContainerWidth*/ ctx[5] + "px", false);
          },
          m(target, anchor) {
            insert(target, div, anchor);

            for (let i = 0; i < each_blocks.length; i += 1) {
              each_blocks[i].m(div, null);
            }

            current = true;
          },
          p(ctx, dirty) {
            if (dirty[0] & /*incompleteTasks, markToDo, handleNewTodo, showTileNewTodo, showTask*/ 473956356) {
              each_value_1 = /*incompleteTasks*/ ctx[2];
              group_outros();
              each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, div, outro_and_destroy_block, create_each_block_1, null, get_each_context_1);
              check_outros();
            }

            if (dirty[0] & /*keyContainerWidth*/ 32) {
              set_style(div, "width", /*keyContainerWidth*/ ctx[5] + "px", false);
            }
          },
          i(local) {
            if (current) return;

            for (let i = 0; i < each_value_1.length; i += 1) {
              transition_in(each_blocks[i]);
            }

            current = true;
          },
          o(local) {
            for (let i = 0; i < each_blocks.length; i += 1) {
              transition_out(each_blocks[i]);
            }

            current = false;
          },
          d(detaching) {
            if (detaching) detach(div);

            for (let i = 0; i < each_blocks.length; i += 1) {
              each_blocks[i].d();
            }
          },
        };
      }

      // (463:16) {#if task.newTodo === true}
      function create_if_block_5(ctx) {
        let div1;
        let input;
        let t;
        let div0;
        let tickicon;
        let current;
        let mounted;
        let dispose;

        function input_input_handler() {
          /*input_input_handler*/ ctx[36].call(input, /*each_value_1*/ ctx[70], /*idx*/ ctx[71]);
        }

        tickicon = new TickIcon({});

        function click_handler_4(...args) {
          return /*click_handler_4*/ ctx[37](/*task*/ ctx[67], ...args);
        }

        return {
          c() {
            div1 = element("div");
            input = element("input");
            t = space();
            div0 = element("div");
            create_component(tickicon.$$.fragment);
            attr(input, "type", "text");
            attr(input, "class", "newTodo svelte-1wz5uuo");
            attr(input, "placeholder", "New todo");
            attr(div0, "class", "tickIcon svelte-1wz5uuo");
            attr(div1, "class", "newTodoTileWrapper svelte-1wz5uuo");
          },
          m(target, anchor) {
            insert(target, div1, anchor);
            append(div1, input);
            set_input_value(input, /*task*/ ctx[67].tileNewToDoText);
            append(div1, t);
            append(div1, div0);
            mount_component(tickicon, div0, null);
            current = true;

            if (!mounted) {
              dispose = [listen(input, "input", input_input_handler), listen(div0, "click", click_handler_4)];

              mounted = true;
            }
          },
          p(new_ctx, dirty) {
            ctx = new_ctx;

            if (dirty[0] & /*incompleteTasks*/ 4 && input.value !== /*task*/ ctx[67].tileNewToDoText) {
              set_input_value(input, /*task*/ ctx[67].tileNewToDoText);
            }
          },
          i(local) {
            if (current) return;
            transition_in(tickicon.$$.fragment, local);
            current = true;
          },
          o(local) {
            transition_out(tickicon.$$.fragment, local);
            current = false;
          },
          d(detaching) {
            if (detaching) detach(div1);
            destroy_component(tickicon);
            mounted = false;
            run_all(dispose);
          },
        };
      }

      // (475:20) {#each task.todos.filter((t, idx) => t.completed === false) as todo (todo.id)}
      function create_each_block_3(key_1, ctx) {
        let li;
        let t0_value = /*todo*/ ctx[72].name + "";
        let t0;
        let t1;
        let li_intro;
        let li_outro;
        let current;
        let mounted;
        let dispose;

        function click_handler_5() {
          return /*click_handler_5*/ ctx[38](/*todo*/ ctx[72]);
        }

        return {
          key: key_1,
          first: null,
          c() {
            li = element("li");
            t0 = text(t0_value);
            t1 = space();
            attr(li, "class", "todo svelte-1wz5uuo");
            this.first = li;
          },
          m(target, anchor) {
            insert(target, li, anchor);
            append(li, t0);
            append(li, t1);
            current = true;

            if (!mounted) {
              dispose = listen(li, "click", click_handler_5);
              mounted = true;
            }
          },
          p(new_ctx, dirty) {
            ctx = new_ctx;
            if ((!current || dirty[0] & /*incompleteTasks*/ 4) && t0_value !== (t0_value = /*todo*/ ctx[72].name + "")) set_data(t0, t0_value);
          },
          i(local) {
            if (current) return;

            add_render_callback(() => {
              if (li_outro) li_outro.end(1);
              li_intro = create_in_transition(li, /*receive*/ ctx[14], { key: /*todo*/ ctx[72].id, duration: 500 });
              li_intro.start();
            });

            current = true;
          },
          o(local) {
            if (li_intro) li_intro.invalidate();
            li_outro = create_out_transition(li, /*send*/ ctx[13], { key: /*todo*/ ctx[72].id, duration: 500 });
            current = false;
          },
          d(detaching) {
            if (detaching) detach(li);
            if (detaching && li_outro) li_outro.end();
            mounted = false;
            dispose();
          },
        };
      }

      // (488:20) {#each task.todos.filter((t) => t.completed === true) as todo (todo.id)}
      function create_each_block_2(key_1, ctx) {
        let li;
        let t0_value = /*todo*/ ctx[72].name + "";
        let t0;
        let t1;
        let li_intro;
        let li_outro;
        let current;
        let mounted;
        let dispose;

        function click_handler_6() {
          return /*click_handler_6*/ ctx[39](/*todo*/ ctx[72]);
        }

        return {
          key: key_1,
          first: null,
          c() {
            li = element("li");
            t0 = text(t0_value);
            t1 = space();
            attr(li, "class", "todo completedTodo svelte-1wz5uuo");
            this.first = li;
          },
          m(target, anchor) {
            insert(target, li, anchor);
            append(li, t0);
            append(li, t1);
            current = true;

            if (!mounted) {
              dispose = listen(li, "click", click_handler_6);
              mounted = true;
            }
          },
          p(new_ctx, dirty) {
            ctx = new_ctx;
            if ((!current || dirty[0] & /*incompleteTasks*/ 4) && t0_value !== (t0_value = /*todo*/ ctx[72].name + "")) set_data(t0, t0_value);
          },
          i(local) {
            if (current) return;

            add_render_callback(() => {
              if (li_outro) li_outro.end(1);
              li_intro = create_in_transition(li, /*receive*/ ctx[14], { key: /*todo*/ ctx[72].id, duration: 500 });
              li_intro.start();
            });

            current = true;
          },
          o(local) {
            if (li_intro) li_intro.invalidate();
            li_outro = create_out_transition(li, /*send*/ ctx[13], { key: /*todo*/ ctx[72].id, duration: 500 });
            current = false;
          },
          d(detaching) {
            if (detaching) detach(li);
            if (detaching && li_outro) li_outro.end();
            mounted = false;
            dispose();
          },
        };
      }

      // (422:8) {#each incompleteTasks as task, idx (task.id)}
      function create_each_block_1(key_1, ctx) {
        let div12;
        let div2;
        let div0;
        let t0_value = /*idx*/ ctx[71] + 1 + "";
        let t0;
        let t1;
        let t2_value = /*task*/ ctx[67].name + "";
        let t2;
        let t3;
        let div1;
        let addicon;
        let t4;
        let div7;
        let div3;
        let t5;
        let div6;
        let div4;
        let t6_value = formatTime(/*task*/ ctx[67].elapsed) + "";
        let t6;
        let t7;
        let div5;
        let t8_value = /*task*/ ctx[67].duration * 60 + "";
        let t8;
        let t9;
        let t10;
        let div11;
        let div10;
        let t11;
        let div9;
        let div8;
        let t13;
        let ul0;
        let each_blocks_1 = [];
        let each0_lookup = new Map();
        let t14;
        let ul1;
        let each_blocks = [];
        let each1_lookup = new Map();
        let t15;
        let current;
        let mounted;
        let dispose;

        function click_handler_2() {
          return /*click_handler_2*/ ctx[34](/*task*/ ctx[67]);
        }

        addicon = new AddIcon({
          props: {
            strokeColor: "var(--lightGrey2)",
            strokeWidth: ".3",
          },
        });

        function click_handler_3() {
          return /*click_handler_3*/ ctx[35](/*task*/ ctx[67]);
        }

        let if_block = /*task*/ ctx[67].newTodo === true && create_if_block_5(ctx);
        let each_value_3 = /*task*/ ctx[67].todos.filter(func);
        const get_key = (ctx) => /*todo*/ ctx[72].id;

        for (let i = 0; i < each_value_3.length; i += 1) {
          let child_ctx = get_each_context_3(ctx, each_value_3, i);
          let key = get_key(child_ctx);
          each0_lookup.set(key, (each_blocks_1[i] = create_each_block_3(key, child_ctx)));
        }

        let each_value_2 = /*task*/ ctx[67].todos.filter(func_1);
        const get_key_1 = (ctx) => /*todo*/ ctx[72].id;

        for (let i = 0; i < each_value_2.length; i += 1) {
          let child_ctx = get_each_context_2(ctx, each_value_2, i);
          let key = get_key_1(child_ctx);
          each1_lookup.set(key, (each_blocks[i] = create_each_block_2(key, child_ctx)));
        }

        return {
          key: key_1,
          first: null,
          c() {
            div12 = element("div");
            div2 = element("div");
            div0 = element("div");
            t0 = text(t0_value);
            t1 = text(". ");
            t2 = text(t2_value);
            t3 = space();
            div1 = element("div");
            create_component(addicon.$$.fragment);
            t4 = space();
            div7 = element("div");
            div3 = element("div");
            t5 = space();
            div6 = element("div");
            div4 = element("div");
            t6 = text(t6_value);
            t7 = space();
            div5 = element("div");
            t8 = text(t8_value);
            t9 = text(" mins");
            t10 = space();
            div11 = element("div");
            div10 = element("div");
            if (if_block) if_block.c();
            t11 = space();
            div9 = element("div");
            div8 = element("div");
            div8.textContent = "To do:";
            t13 = space();
            ul0 = element("ul");

            for (let i = 0; i < each_blocks_1.length; i += 1) {
              each_blocks_1[i].c();
            }

            t14 = space();
            ul1 = element("ul");

            for (let i = 0; i < each_blocks.length; i += 1) {
              each_blocks[i].c();
            }

            t15 = space();
            attr(div0, "class", "taskName svelte-1wz5uuo");
            attr(div1, "class", "addTodo svelte-1wz5uuo");
            attr(div2, "class", "taskDetailsHeader svelte-1wz5uuo");
            attr(div3, "class", "taskProgressDuration svelte-1wz5uuo");
            set_style(div3, "--progressPercentage", (100 * /*task*/ ctx[67].elapsed) / /*task*/ (ctx[67].duration * 60 * 60 * 1000) + "%");
            set_style(div3, "--progressPercentageStart", (100 * /*task*/ ctx[67].elapsed) / /*task*/ (ctx[67].duration * 60 * 60 * 1000) + 1 + "%");
            set_style(div3, "--progressPercentageEnd", (100 * /*task*/ ctx[67].elapsed) / /*task*/ (ctx[67].duration * 60 * 60 * 1000) + 2 + "%");
            attr(div4, "class", "elapsed");
            attr(div5, "class", "duration");
            attr(div6, "class", "taskDurationWrapper svelte-1wz5uuo");
            attr(div7, "class", "taskDetailsProgress svelte-1wz5uuo");
            attr(div8, "class", "todoHeading svelte-1wz5uuo");
            attr(ul0, "class", "incompleteList svelte-1wz5uuo");
            attr(ul1, "class", "completedList svelte-1wz5uuo");
            attr(div9, "class", "todoLists svelte-1wz5uuo");
            attr(div10, "class", "taskDetailsContent svelte-1wz5uuo");
            attr(div11, "class", "todoWrapper svelte-1wz5uuo");
            attr(div12, "class", "taskDetailsWrapper svelte-1wz5uuo");
            toggle_class(div12, "active", /*task*/ ctx[67].active === true);
            this.first = div12;
          },
          m(target, anchor) {
            insert(target, div12, anchor);
            append(div12, div2);
            append(div2, div0);
            append(div0, t0);
            append(div0, t1);
            append(div0, t2);
            append(div2, t3);
            append(div2, div1);
            mount_component(addicon, div1, null);
            append(div12, t4);
            append(div12, div7);
            append(div7, div3);
            append(div7, t5);
            append(div7, div6);
            append(div6, div4);
            append(div4, t6);
            append(div6, t7);
            append(div6, div5);
            append(div5, t8);
            append(div5, t9);
            append(div12, t10);
            append(div12, div11);
            append(div11, div10);
            if (if_block) if_block.m(div10, null);
            append(div10, t11);
            append(div10, div9);
            append(div9, div8);
            append(div9, t13);
            append(div9, ul0);

            for (let i = 0; i < each_blocks_1.length; i += 1) {
              each_blocks_1[i].m(ul0, null);
            }

            append(div9, t14);
            append(div9, ul1);

            for (let i = 0; i < each_blocks.length; i += 1) {
              each_blocks[i].m(ul1, null);
            }

            append(div12, t15);
            current = true;

            if (!mounted) {
              dispose = [listen(div0, "click", click_handler_2), listen(div1, "click", click_handler_3)];

              mounted = true;
            }
          },
          p(new_ctx, dirty) {
            ctx = new_ctx;
            if ((!current || dirty[0] & /*incompleteTasks*/ 4) && t0_value !== (t0_value = /*idx*/ ctx[71] + 1 + "")) set_data(t0, t0_value);
            if ((!current || dirty[0] & /*incompleteTasks*/ 4) && t2_value !== (t2_value = /*task*/ ctx[67].name + "")) set_data(t2, t2_value);

            if (!current || dirty[0] & /*incompleteTasks*/ 4) {
              set_style(div3, "--progressPercentage", (100 * /*task*/ ctx[67].elapsed) / /*task*/ (ctx[67].duration * 60 * 60 * 1000) + "%");
            }

            if (!current || dirty[0] & /*incompleteTasks*/ 4) {
              set_style(div3, "--progressPercentageStart", (100 * /*task*/ ctx[67].elapsed) / /*task*/ (ctx[67].duration * 60 * 60 * 1000) + 1 + "%");
            }

            if (!current || dirty[0] & /*incompleteTasks*/ 4) {
              set_style(div3, "--progressPercentageEnd", (100 * /*task*/ ctx[67].elapsed) / /*task*/ (ctx[67].duration * 60 * 60 * 1000) + 2 + "%");
            }

            if ((!current || dirty[0] & /*incompleteTasks*/ 4) && t6_value !== (t6_value = formatTime(/*task*/ ctx[67].elapsed) + "")) set_data(t6, t6_value);
            if ((!current || dirty[0] & /*incompleteTasks*/ 4) && t8_value !== (t8_value = /*task*/ ctx[67].duration * 60 + "")) set_data(t8, t8_value);

            if (/*task*/ ctx[67].newTodo === true) {
              if (if_block) {
                if_block.p(ctx, dirty);

                if (dirty[0] & /*incompleteTasks*/ 4) {
                  transition_in(if_block, 1);
                }
              } else {
                if_block = create_if_block_5(ctx);
                if_block.c();
                transition_in(if_block, 1);
                if_block.m(div10, t11);
              }
            } else if (if_block) {
              group_outros();

              transition_out(if_block, 1, 1, () => {
                if_block = null;
              });

              check_outros();
            }

            if (dirty[0] & /*incompleteTasks, markToDo*/ 268435460) {
              each_value_3 = /*task*/ ctx[67].todos.filter(func);
              group_outros();
              each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx, each_value_3, each0_lookup, ul0, outro_and_destroy_block, create_each_block_3, null, get_each_context_3);
              check_outros();
            }

            if (dirty[0] & /*incompleteTasks, markToDo*/ 268435460) {
              each_value_2 = /*task*/ ctx[67].todos.filter(func_1);
              group_outros();
              each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx, each_value_2, each1_lookup, ul1, outro_and_destroy_block, create_each_block_2, null, get_each_context_2);
              check_outros();
            }

            if (dirty[0] & /*incompleteTasks*/ 4) {
              toggle_class(div12, "active", /*task*/ ctx[67].active === true);
            }
          },
          i(local) {
            if (current) return;
            transition_in(addicon.$$.fragment, local);
            transition_in(if_block);

            for (let i = 0; i < each_value_3.length; i += 1) {
              transition_in(each_blocks_1[i]);
            }

            for (let i = 0; i < each_value_2.length; i += 1) {
              transition_in(each_blocks[i]);
            }

            current = true;
          },
          o(local) {
            transition_out(addicon.$$.fragment, local);
            transition_out(if_block);

            for (let i = 0; i < each_blocks_1.length; i += 1) {
              transition_out(each_blocks_1[i]);
            }

            for (let i = 0; i < each_blocks.length; i += 1) {
              transition_out(each_blocks[i]);
            }

            current = false;
          },
          d(detaching) {
            if (detaching) detach(div12);
            destroy_component(addicon);
            if (if_block) if_block.d();

            for (let i = 0; i < each_blocks_1.length; i += 1) {
              each_blocks_1[i].d();
            }

            for (let i = 0; i < each_blocks.length; i += 1) {
              each_blocks[i].d();
            }

            mounted = false;
            run_all(dispose);
          },
        };
      }

      // (524:2) {#each incompleteTasks.filter((t) => t.active === true) as task (task.id)}
      function create_each_block(key_1, ctx) {
        let first;
        let watch;
        let updating_lapse;
        let updating_laps;
        let current;

        function watch_lapse_binding(value) {
          /*watch_lapse_binding*/ ctx[41](value, /*task*/ ctx[67]);
        }

        function watch_laps_binding(value) {
          /*watch_laps_binding*/ ctx[42](value, /*task*/ ctx[67]);
        }

        let watch_props = { paused: /*task*/ ctx[67].active };

        if (/*task*/ ctx[67].elapsed !== void 0) {
          watch_props.lapse = /*task*/ ctx[67].elapsed;
        }

        if (/*task*/ ctx[67].laps !== void 0) {
          watch_props.laps = /*task*/ ctx[67].laps;
        }

        watch = new Watch({ props: watch_props });
        binding_callbacks.push(() => bind(watch, "lapse", watch_lapse_binding));
        binding_callbacks.push(() => bind(watch, "laps", watch_laps_binding));

        return {
          key: key_1,
          first: null,
          c() {
            first = empty();
            create_component(watch.$$.fragment);
            this.first = first;
          },
          m(target, anchor) {
            insert(target, first, anchor);
            mount_component(watch, target, anchor);
            current = true;
          },
          p(new_ctx, dirty) {
            ctx = new_ctx;
            const watch_changes = {};
            if (dirty[0] & /*incompleteTasks*/ 4) watch_changes.paused = /*task*/ ctx[67].active;

            if (!updating_lapse && dirty[0] & /*incompleteTasks*/ 4) {
              updating_lapse = true;
              watch_changes.lapse = /*task*/ ctx[67].elapsed;
              add_flush_callback(() => (updating_lapse = false));
            }

            if (!updating_laps && dirty[0] & /*incompleteTasks*/ 4) {
              updating_laps = true;
              watch_changes.laps = /*task*/ ctx[67].laps;
              add_flush_callback(() => (updating_laps = false));
            }

            watch.$set(watch_changes);
          },
          i(local) {
            if (current) return;
            transition_in(watch.$$.fragment, local);
            current = true;
          },
          o(local) {
            transition_out(watch.$$.fragment, local);
            current = false;
          },
          d(detaching) {
            if (detaching) detach(first);
            destroy_component(watch, detaching);
          },
        };
      }

      // (529:0) {#if showReport === true}
      function create_if_block_2$1(ctx) {
        let div;
        let report;
        let current;

        report = new Report({
          props: { tasks: /*incompleteTasks*/ ctx[2] },
        });

        report.$on("close", /*close_handler*/ ctx[43]);

        return {
          c() {
            div = element("div");
            create_component(report.$$.fragment);
            attr(div, "class", "reportModal svelte-1wz5uuo");
          },
          m(target, anchor) {
            insert(target, div, anchor);
            mount_component(report, div, null);
            current = true;
          },
          p(ctx, dirty) {
            const report_changes = {};
            if (dirty[0] & /*incompleteTasks*/ 4) report_changes.tasks = /*incompleteTasks*/ ctx[2];
            report.$set(report_changes);
          },
          i(local) {
            if (current) return;
            transition_in(report.$$.fragment, local);
            current = true;
          },
          o(local) {
            transition_out(report.$$.fragment, local);
            current = false;
          },
          d(detaching) {
            if (detaching) detach(div);
            destroy_component(report);
          },
        };
      }

      // (535:0) {#if showCompletedTasks === true}
      function create_if_block_1$1(ctx) {
        let div;
        let completedtasks;
        let current;

        completedtasks = new CompletedTasks({
          props: {
            completedTasks: /*completedTasks*/ ctx[12],
            incompleteTasks: /*incompleteTasks*/ ctx[2],
          },
        });

        completedtasks.$on("close", /*close_handler_1*/ ctx[44]);
        completedtasks.$on("markstatus", /*markStatus*/ ctx[29]);

        return {
          c() {
            div = element("div");
            create_component(completedtasks.$$.fragment);
            attr(div, "class", "completedTasks svelte-1wz5uuo");
          },
          m(target, anchor) {
            insert(target, div, anchor);
            mount_component(completedtasks, div, null);
            current = true;
          },
          p(ctx, dirty) {
            const completedtasks_changes = {};
            if (dirty[0] & /*completedTasks*/ 4096) completedtasks_changes.completedTasks = /*completedTasks*/ ctx[12];
            if (dirty[0] & /*incompleteTasks*/ 4) completedtasks_changes.incompleteTasks = /*incompleteTasks*/ ctx[2];
            completedtasks.$set(completedtasks_changes);
          },
          i(local) {
            if (current) return;
            transition_in(completedtasks.$$.fragment, local);
            current = true;
          },
          o(local) {
            transition_out(completedtasks.$$.fragment, local);
            current = false;
          },
          d(detaching) {
            if (detaching) detach(div);
            destroy_component(completedtasks);
          },
        };
      }

      // (546:0) {#if showHorizonModal === true}
      function create_if_block$1(ctx) {
        let div2;
        let div1;
        let h5;
        let t1;
        let p0;
        let t3;
        let div0;
        let t10;
        let p4;
        let t12;
        let button;
        let mounted;
        let dispose;

        return {
          c() {
            div2 = element("div");
            div1 = element("div");
            h5 = element("h5");
            // h5.textContent = "Horizon code copied!";
            t1 = space();
            p0 = element("p");
            p0.textContent = "Ignore this";
            t3 = space();
            div0 = element("div");

            t10 = space();
            p4 = element("p");
            // p4.textContent = "Your horizon timesheet should now have hours auto filled. If the hours are accurate, click Save and you are\n        done!";
            t12 = space();
            button = element("button");
            button.textContent = "Back";
            attr(h5, "class", "svelte-1wz5uuo");
            attr(p0, "class", "svelte-1wz5uuo");
            attr(div0, "class", "instructionWrapper svelte-1wz5uuo");
            attr(p4, "class", "svelte-1wz5uuo");
            attr(button, "class", "close svelte-1wz5uuo");
            attr(button, "type", "submit");
            attr(div1, "class", "horizonInstructions svelte-1wz5uuo");
            attr(div2, "class", "completedTasks svelte-1wz5uuo");
          },
          m(target, anchor) {
            insert(target, div2, anchor);
            append(div2, div1);
            append(div1, h5);
            append(div1, t1);
            append(div1, p0);
            append(div1, t3);
            append(div1, div0);
            append(div1, t10);
            append(div1, p4);
            append(div1, t12);
            append(div1, button);

            if (!mounted) {
              dispose = listen(button, "click", /*click_handler_7*/ ctx[45]);
              mounted = true;
            }
          },
          p: noop,
          d(detaching) {
            if (detaching) detach(div2);
            mounted = false;
            dispose();
          },
        };
      }

      function create_fragment$1(ctx) {
        let link0;
        let link1;
        let link2;
        let t0;
        let t1;
        let div;
        let button;
        let t3;
        let t4;
        let t5;
        let t6;
        let t7;
        let if_block5_anchor;
        let current;
        let mounted;
        let dispose;
        let if_block0 = /*showNewTask*/ ctx[0] === true && create_if_block_7(ctx);
        let if_block1 = /*$tasks*/ ctx[4].length > 0 && create_if_block_6(ctx);
        let if_block2 = /*incompleteTasks*/ ctx[2].length > 0 && create_if_block_3$1(ctx);
        let if_block3 = /*showReport*/ ctx[6] === true && create_if_block_2$1(ctx);
        let if_block4 = /*showCompletedTasks*/ ctx[9] === true && create_if_block_1$1(ctx);
        let if_block5 = /*showHorizonModal*/ ctx[7] === true && create_if_block$1(ctx);

        return {
          c() {
            link0 = element("link");
            link1 = element("link");
            link2 = element("link");
            t0 = space();
            if (if_block0) if_block0.c();
            t1 = space();
            div = element("div");
            button = element("button");
            button.textContent = "New task";
            t3 = space();
            if (if_block1) if_block1.c();
            t4 = space();
            if (if_block2) if_block2.c();
            t5 = space();
            if (if_block3) if_block3.c();
            t6 = space();
            if (if_block4) if_block4.c();
            t7 = space();
            if (if_block5) if_block5.c();
            if_block5_anchor = empty();
            attr(link0, "rel", "preconnect");
            attr(link0, "href", "https://fonts.googleapis.com");
            attr(link1, "rel", "preconnect");
            attr(link1, "href", "https://fonts.gstatic.com");
            attr(link1, "crossorigin", "true");
            attr(link2, "href", "https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap");
            attr(link2, "rel", "stylesheet");
            attr(button, "class", "tButton");
            attr(div, "class", "navButtonsWrapper svelte-1wz5uuo");
          },
          m(target, anchor) {
            append(document_1.head, link0);
            append(document_1.head, link1);
            append(document_1.head, link2);
            insert(target, t0, anchor);
            if (if_block0) if_block0.m(target, anchor);
            insert(target, t1, anchor);
            insert(target, div, anchor);
            append(div, button);
            append(div, t3);
            if (if_block1) if_block1.m(div, null);
            insert(target, t4, anchor);
            if (if_block2) if_block2.m(target, anchor);
            insert(target, t5, anchor);
            if (if_block3) if_block3.m(target, anchor);
            insert(target, t6, anchor);
            if (if_block4) if_block4.m(target, anchor);
            insert(target, t7, anchor);
            if (if_block5) if_block5.m(target, anchor);
            insert(target, if_block5_anchor, anchor);
            current = true;

            if (!mounted) {
              dispose = listen(button, "click", /*click_handler*/ ctx[30]);
              mounted = true;
            }
          },
          p(ctx, dirty) {
            if (/*showNewTask*/ ctx[0] === true) {
              if (if_block0) {
                if_block0.p(ctx, dirty);

                if (dirty[0] & /*showNewTask*/ 1) {
                  transition_in(if_block0, 1);
                }
              } else {
                if_block0 = create_if_block_7(ctx);
                if_block0.c();
                transition_in(if_block0, 1);
                if_block0.m(t1.parentNode, t1);
              }
            } else if (if_block0) {
              group_outros();

              transition_out(if_block0, 1, 1, () => {
                if_block0 = null;
              });

              check_outros();
            }

            if (/*$tasks*/ ctx[4].length > 0) {
              if (if_block1) {
                if_block1.p(ctx, dirty);
              } else {
                if_block1 = create_if_block_6(ctx);
                if_block1.c();
                if_block1.m(div, null);
              }
            } else if (if_block1) {
              if_block1.d(1);
              if_block1 = null;
            }

            if (/*incompleteTasks*/ ctx[2].length > 0) {
              if (if_block2) {
                if_block2.p(ctx, dirty);

                if (dirty[0] & /*incompleteTasks*/ 4) {
                  transition_in(if_block2, 1);
                }
              } else {
                if_block2 = create_if_block_3$1(ctx);
                if_block2.c();
                transition_in(if_block2, 1);
                if_block2.m(t5.parentNode, t5);
              }
            } else if (if_block2) {
              group_outros();

              transition_out(if_block2, 1, 1, () => {
                if_block2 = null;
              });

              check_outros();
            }

            if (/*showReport*/ ctx[6] === true) {
              if (if_block3) {
                if_block3.p(ctx, dirty);

                if (dirty[0] & /*showReport*/ 64) {
                  transition_in(if_block3, 1);
                }
              } else {
                if_block3 = create_if_block_2$1(ctx);
                if_block3.c();
                transition_in(if_block3, 1);
                if_block3.m(t6.parentNode, t6);
              }
            } else if (if_block3) {
              group_outros();

              transition_out(if_block3, 1, 1, () => {
                if_block3 = null;
              });

              check_outros();
            }

            if (/*showCompletedTasks*/ ctx[9] === true) {
              if (if_block4) {
                if_block4.p(ctx, dirty);

                if (dirty[0] & /*showCompletedTasks*/ 512) {
                  transition_in(if_block4, 1);
                }
              } else {
                if_block4 = create_if_block_1$1(ctx);
                if_block4.c();
                transition_in(if_block4, 1);
                if_block4.m(t7.parentNode, t7);
              }
            } else if (if_block4) {
              group_outros();

              transition_out(if_block4, 1, 1, () => {
                if_block4 = null;
              });

              check_outros();
            }

            if (/*showHorizonModal*/ ctx[7] === true) {
              if (if_block5) {
                if_block5.p(ctx, dirty);
              } else {
                if_block5 = create_if_block$1(ctx);
                if_block5.c();
                if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
              }
            } else if (if_block5) {
              if_block5.d(1);
              if_block5 = null;
            }
          },
          i(local) {
            if (current) return;
            transition_in(if_block0);
            transition_in(if_block2);
            transition_in(if_block3);
            transition_in(if_block4);
            current = true;
          },
          o(local) {
            transition_out(if_block0);
            transition_out(if_block2);
            transition_out(if_block3);
            transition_out(if_block4);
            current = false;
          },
          d(detaching) {
            detach(link0);
            detach(link1);
            detach(link2);
            if (detaching) detach(t0);
            if (if_block0) if_block0.d(detaching);
            if (detaching) detach(t1);
            if (detaching) detach(div);
            if (if_block1) if_block1.d();
            if (detaching) detach(t4);
            if (if_block2) if_block2.d(detaching);
            if (detaching) detach(t5);
            if (if_block3) if_block3.d(detaching);
            if (detaching) detach(t6);
            if (if_block4) if_block4.d(detaching);
            if (detaching) detach(t7);
            if (if_block5) if_block5.d(detaching);
            if (detaching) detach(if_block5_anchor);
            mounted = false;
            dispose();
          },
        };
      }

      const func = (t, idx) => t.completed === false;
      const func_1 = (t) => t.completed === true;
      const func_2 = (t) => t.active === true;

      function instance$1($$self, $$props, $$invalidate) {
        let incompleteTasks;
        let completedTasks;
        let gridTemplateColums;
        let gridTemplateRowsPercent;
        let keyContainerHeight;
        let selectedTask;
        let $tasks;
        const [send, receive] = crossfade({});
        let keySound = new Audio("./assets/key.wav");
        let tasksTemplate = [];

        // let tasks = writable();
        let data = JSON.parse(localStorage.getItem("trackey"));

        if (data !== null) {
          tasksTemplate = data;
        }

        let tasks = writable(tasksTemplate);
        component_subscribe($$self, tasks, (value) => $$invalidate(4, ($tasks = value)));

        let previouslySelectedTask = null;
        let lapStart, lapEnd;

        function handleMouseDown(task) {
          keySound.currentTime = 0;
          keySound.play();
          task.pressed = !task.pressed;

          if (previouslySelectedTask !== null && previouslySelectedTask !== task && previouslySelectedTask.active === true) {
            previouslySelectedTask.active = false;
            lapEnd = new Date().toISOString();
            let newLap = { start: lapStart, end: lapEnd };
            previouslySelectedTask.laps = [...previouslySelectedTask.laps, newLap];
          }

          task.active = !task.active;

          if (task.active === true) {
            lapStart = new Date().toISOString();
          } else {
            lapEnd = new Date().toISOString();
            let newLap = { start: lapStart, end: lapEnd };
            task.laps = [...task.laps, newLap];
          }

          previouslySelectedTask = task;
          $$invalidate(2, incompleteTasks), $$invalidate(4, $tasks);
        }

        function saveToLocalStorage() {
          localStorage.setItem("trackey", JSON.stringify($tasks));
        }

        function handleMouseUp(task) {
          task.pressed = false;
          $$invalidate(2, incompleteTasks), $$invalidate(4, $tasks);
          saveToLocalStorage();
        }

        // $: console.log(selectedTask);
        function keyDownEventFunctionWrapper(e) {
          if (Number(e.key) < incompleteTasks.length + 1 && Number(e.key) > 0) {
            handleMouseDown(incompleteTasks[+e.key - 1]);
          }
        }

        function keyUpEventFunctionWrapper(e) {
          if (e.key === "N" || e.key === "n") {
            $$invalidate(0, (showNewTask = true));
          }

          handleMouseUp(incompleteTasks[+e.key - 1]);
        }

        function addEventListeners() {
          window.addEventListener("keydown", keyDownEventFunctionWrapper);
          window.addEventListener("keyup", keyUpEventFunctionWrapper);
          console.log("Added event listeners");
        }

        function removeEventListeners() {
          window.removeEventListener("keydown", keyDownEventFunctionWrapper);
          window.removeEventListener("keyup", keyUpEventFunctionWrapper);
          console.log("removed event listeners");
        }

        addEventListeners();

        window.addEventListener("beforeunload", () => {
          selectedTask.active = false;
          saveToLocalStorage();
        });

        let keyContainerWidth = 0;

        function reportWidth(node, updated) {
          //FIXME: handle Width update
          $$invalidate(5, (keyContainerWidth = node.offsetWidth));

          return {
            update(updated) {
              $$invalidate(5, (keyContainerWidth = node.offsetWidth));
            },
          };
        }

        // $: console.log(incompleteTasks);
        //TIMER
        //NEW TASK
        let showNewTask = false;

        function addTask(e) {
          let task = e.detail;
          task.id = "T" + String(new Date().valueOf());
          set_store_value(tasks, ($tasks = [...$tasks, task]), $tasks);
          $$invalidate(0, (showNewTask = false));
          saveToLocalStorage();
        }

        function cancelAddTask() {
          $$invalidate(0, (showNewTask = false));
        }

        //REPORT
        let showReport = false;

        //PREPARE HORIZON REPORT
        let lastMonday = firstDayOfWeek(new Date(), 1);

        let weekDates = getDaysArray(lastMonday, addDays(lastMonday, 6));

        var dateOptions = {
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
        };

        // @ts-ignore
        let weekDatesGetDates = new Set(weekDates.map((date) => date.toLocaleDateString("en-US", dateOptions)));

        let currentWeekProjects = {};

        // rows[0].children[1].children[4].value
        // rows[0].children[1].children[5]
        //COPY TO HORIZON
        let showHorizonModal = false;

        function copyHorizonCode() {
          $$invalidate(7, (showHorizonModal = true));

          function copyToHorizon() {
            let horizonRows = document.querySelectorAll(".project");

            horizonRows.forEach((row) => {
              let projectName = row.querySelector(".project-name").textContent.trim();
              let curWeekProjsObj = JSON.parse(currentWeekProjects);

              if (curWeekProjsObj[projectName]) {
                Object.entries(curWeekProjsObj[projectName]).forEach(([dateStringKey, hoursValue]) => {
                  let domImputReference = row.querySelector(`input[value="${dateStringKey}"]`);
                  let inputField = domImputReference.nextSibling;

                  // @ts-ignore
                  inputField.value = hoursValue;
                }); // console.log(domImputReference.nextSibling);
              }
            });
          }

          let prefix = "let currentWeekProjects = '";
          let suffix = "';";
          let currentWprojects = JSON.stringify(prepareReport());
          let functionAsText = copyToHorizon.toString();
          navigator.clipboard.writeText(prefix + " " + currentWprojects + " " + suffix + "\n" + functionAsText + "\n" + functionAsText.split(" ")[1].split("{")[0]);
        }

        // COPY FROM HORIZON
        let horizonRows2 = document.querySelectorAll(".project");

        setTimeout(() => {
          let projectNames = [];

          horizonRows2.forEach((row) => {
            let projectName = row.querySelector(".project-name").textContent.trim();
            projectNames.push(projectName);
          });

          navigator.clipboard.writeText(projectNames.join());
        }, 2000);

        function prepareReport() {
          currentWeekProjects = {};

          incompleteTasks.map((task) => {
            task.laps.map((lap) => {
              let lapDate = new Date(lap.start);

              // @ts-ignore
              let lapDateString = lapDate.toLocaleDateString("en-US", dateOptions);

              if (weekDatesGetDates.has(lapDateString)) {
                // @ts-ignore
                let lapTime = new Date(lap.end) - new Date(lap.start);

                if (currentWeekProjects[task.name] === undefined) {
                  currentWeekProjects[task.name] = {};
                  currentWeekProjects[task.name][lapDateString] = +(Math.ceil(lapTime / 1000 / 60) / 60).toFixed(1);
                } else {
                  currentWeekProjects[task.name][lapDateString] += +(Math.ceil(lapTime / 1000 / 60) / 60).toFixed(1);
                }
              } // let lapTime = new Date(lap.end) - new Date(lap.start);
              // laps.push({
            }); //   date: lapDate.toLocaleDateString("en-US", dateOptions),
            //   time: lapTime,
            //   task: task.name,
            // });
          });

          return currentWeekProjects;
        }

        // $: console.log(currentWeekProjects);
        let showTaskModal = false;

        let shownTask = undefined;

        function showTask(task) {
          $$invalidate(1, (showTaskModal = true));
          $$invalidate(8, (shownTask = task));
        }

        function updateTask(e) {
          $$invalidate(2, incompleteTasks), $$invalidate(4, $tasks);
          $$invalidate(1, (showTaskModal = false));
          saveToLocalStorage();
        }

        function deleteTask(e) {
          $$invalidate(2, (incompleteTasks = incompleteTasks.filter((t) => t.id !== e.detail.id)));
          $$invalidate(1, (showTaskModal = false));
          saveToLocalStorage();
        }

        function completeTask(e) {
          let taskToMarkComplete = incompleteTasks.find((t) => t.id === e.detail.id);
          taskToMarkComplete.completed = true;
          $$invalidate(2, incompleteTasks), $$invalidate(4, $tasks);
          $$invalidate(1, (showTaskModal = false));
          saveToLocalStorage();
        }

        //ADD TODO FROM TILE
        function handleNewTodo(task) {
          if (task.tileNewToDoText !== "") {
            let id = task.todos.length + 1;
            let name = task.tileNewToDoText;
            let completed = false;
            let newTodo = { id, name, completed };
            task.todos = [newTodo, ...task.todos];
            task.tileNewToDoText = "";
            task.newTodo = false;
            $$invalidate(2, incompleteTasks), $$invalidate(4, $tasks);
            saveToLocalStorage();
          }

          task.newTodo = false;
          $$invalidate(2, incompleteTasks), $$invalidate(4, $tasks);
          addEventListeners();
        }

        async function showTileNewTodo(task) {
          removeEventListeners();
          task.newTodo = true;
          tasks.set($tasks);
        } // await tick();
        // task.tileNewToDo.focus();

        function markToDo(todo) {
          todo.completed = !todo.completed;
          $$invalidate(2, incompleteTasks), $$invalidate(4, $tasks);
          saveToLocalStorage();
        }

        let showCompletedTasks = false;

        function markStatus(e) {
          console.log(e.detail.name);
          let taskToMarkIncomplete = e.detail;
          taskToMarkIncomplete.completed = !taskToMarkIncomplete.completed;
          tasks.set($tasks);
          saveToLocalStorage();
        }

        const click_handler = () => $$invalidate(0, (showNewTask = true));
        const click_handler_1 = () => $$invalidate(9, (showCompletedTasks = true));
        const mousedown_handler = (task) => handleMouseDown(task);
        const mouseup_handler = (task) => handleMouseUp(task);
        const click_handler_2 = (task) => showTask(task);
        const click_handler_3 = (task) => showTileNewTodo(task);

        function input_input_handler(each_value_1, idx) {
          each_value_1[idx].tileNewToDoText = this.value;
          $$invalidate(2, incompleteTasks), $$invalidate(4, $tasks);
        }

        const click_handler_4 = (task, e) => handleNewTodo(task);
        const click_handler_5 = (todo) => markToDo(todo);
        const click_handler_6 = (todo) => markToDo(todo);
        const cancel_handler = () => $$invalidate(1, (showTaskModal = false));

        function watch_lapse_binding(value, task) {
          if ($$self.$$.not_equal(task.elapsed, value)) {
            task.elapsed = value;
            $$invalidate(2, incompleteTasks), $$invalidate(4, $tasks);
          }
        }

        function watch_laps_binding(value, task) {
          if ($$self.$$.not_equal(task.laps, value)) {
            task.laps = value;
            $$invalidate(2, incompleteTasks), $$invalidate(4, $tasks);
          }
        }

        const close_handler = () => $$invalidate(6, (showReport = false));
        const close_handler_1 = () => $$invalidate(9, (showCompletedTasks = false));
        const click_handler_7 = () => $$invalidate(7, (showHorizonModal = false));

        $$self.$$.update = () => {
          if ($$self.$$.dirty[0] & /*$tasks*/ 16) {
            $$invalidate(2, (incompleteTasks = $tasks.filter((t) => !t.completed)));
          }

          if ($$self.$$.dirty[0] & /*$tasks*/ 16) {
            $$invalidate(12, (completedTasks = $tasks.filter((t) => t.completed)));
          }

          if ($$self.$$.dirty[0] & /*incompleteTasks*/ 4) {
            $$invalidate(11, (gridTemplateColums = incompleteTasks.length < 4 ? incompleteTasks.length : 4));
          }

          if ($$self.$$.dirty[0] & /*incompleteTasks*/ 4) {
            $$invalidate(
              3,
              (gridTemplateRowsPercent =
                incompleteTasks.length / 4 <= 1
                  ? 100
                  : incompleteTasks.length / 4 > 1 && incompleteTasks.length / 4 <= 2
                  ? 43
                  : incompleteTasks.length / 4 > 2 && incompleteTasks.length / 4 <= 3
                  ? 30
                  : 22)
            );
          }

          if ($$self.$$.dirty[0] & /*incompleteTasks*/ 4) {
            $$invalidate(
              10,
              (keyContainerHeight =
                incompleteTasks.length / 4 <= 1
                  ? 13
                  : incompleteTasks.length / 4 > 1 && incompleteTasks.length / 4 <= 2
                  ? 20
                  : incompleteTasks.length / 4 > 2 && incompleteTasks.length / 4 <= 3
                  ? 40
                  : 50)
            );
          }

          if ($$self.$$.dirty[0] & /*gridTemplateRowsPercent*/ 8) {
            console.log({ gridTemplateRowsPercent });
          }

          if ($$self.$$.dirty[0] & /*incompleteTasks*/ 4) {
            selectedTask = incompleteTasks.filter((t) => t.active === true)[0];
          }

          if ($$self.$$.dirty[0] & /*showNewTask, showTaskModal*/ 3) {
            if (showNewTask === true || showTaskModal === true) {
              removeEventListeners();
            } else {
              addEventListeners();
            }
          }
        };

        return [
          showNewTask,
          showTaskModal,
          incompleteTasks,
          gridTemplateRowsPercent,
          $tasks,
          keyContainerWidth,
          showReport,
          showHorizonModal,
          shownTask,
          showCompletedTasks,
          keyContainerHeight,
          gridTemplateColums,
          completedTasks,
          send,
          receive,
          tasks,
          handleMouseDown,
          handleMouseUp,
          reportWidth,
          addTask,
          cancelAddTask,
          copyHorizonCode,
          showTask,
          updateTask,
          deleteTask,
          completeTask,
          handleNewTodo,
          showTileNewTodo,
          markToDo,
          markStatus,
          click_handler,
          click_handler_1,
          mousedown_handler,
          mouseup_handler,
          click_handler_2,
          click_handler_3,
          input_input_handler,
          click_handler_4,
          click_handler_5,
          click_handler_6,
          cancel_handler,
          watch_lapse_binding,
          watch_laps_binding,
          close_handler,
          close_handler_1,
          click_handler_7,
        ];
      }

      class Main extends SvelteComponent {
        constructor(options) {
          super();
          init(this, options, instance$1, create_fragment$1, safe_not_equal, {}, null, [-1, -1, -1]);
        }
      }

      function typewriter(node, { speed = 1 }) {
        const valid = node.childNodes.length === 1 && node.childNodes[0].nodeType === Node.TEXT_NODE;

        if (!valid) {
          throw new Error(`This transition only works on elements with a single text node child`);
        }

        const text = node.textContent;
        const duration = text.length / (speed * 0.01);

        return {
          duration,
          tick: (t) => {
            const i = Math.trunc(text.length * t);
            node.textContent = text.slice(0, i);
          },
        };
      }

      var App_svelte_svelte_type_style_lang = "";

      /* src/App.svelte generated by Svelte v3.46.4 */

      function create_if_block(ctx) {
        let div;
        let t0;
        let div_intro;
        let t1;
        let t2;
        let if_block2_anchor;
        let current;
        let mounted;
        let dispose;
        let if_block0 = /*logoKeyVisible*/ ctx[1] !== true && create_if_block_3();
        let if_block1 = /*logoKeyVisible*/ ctx[1] === true && create_if_block_2();
        let if_block2 = /*logoKeyVisible*/ ctx[1] === true && create_if_block_1();

        return {
          c() {
            div = element("div");
            t0 = text("trac");
            if (if_block0) if_block0.c();
            t1 = space();
            if (if_block1) if_block1.c();
            t2 = space();
            if (if_block2) if_block2.c();
            if_block2_anchor = empty();
            attr(div, "class", "logoTrac");
          },
          m(target, anchor) {
            insert(target, div, anchor);
            append(div, t0);
            if (if_block0) if_block0.m(div, null);
            insert(target, t1, anchor);
            if (if_block1) if_block1.m(target, anchor);
            insert(target, t2, anchor);
            if (if_block2) if_block2.m(target, anchor);
            insert(target, if_block2_anchor, anchor);
            current = true;

            if (!mounted) {
              dispose = listen(div, "introend", /*introend_handler*/ ctx[3]);
              mounted = true;
            }
          },
          p(ctx, dirty) {
            if (/*logoKeyVisible*/ ctx[1] !== true) {
              if (if_block0);
              else {
                if_block0 = create_if_block_3();
                if_block0.c();
                if_block0.m(div, null);
              }
            } else if (if_block0) {
              if_block0.d(1);
              if_block0 = null;
            }

            if (/*logoKeyVisible*/ ctx[1] === true) {
              if (if_block1) {
                if (dirty & /*logoKeyVisible*/ 2) {
                  transition_in(if_block1, 1);
                }
              } else {
                if_block1 = create_if_block_2();
                if_block1.c();
                transition_in(if_block1, 1);
                if_block1.m(t2.parentNode, t2);
              }
            } else if (if_block1) {
              group_outros();

              transition_out(if_block1, 1, 1, () => {
                if_block1 = null;
              });

              check_outros();
            }

            if (/*logoKeyVisible*/ ctx[1] === true) {
              if (if_block2) {
                if (dirty & /*logoKeyVisible*/ 2) {
                  transition_in(if_block2, 1);
                }
              } else {
                if_block2 = create_if_block_1();
                if_block2.c();
                transition_in(if_block2, 1);
                if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
              }
            } else if (if_block2) {
              group_outros();

              transition_out(if_block2, 1, 1, () => {
                if_block2 = null;
              });

              check_outros();
            }
          },
          i(local) {
            if (current) return;

            if (!div_intro) {
              add_render_callback(() => {
                div_intro = create_in_transition(div, slide, {});
                div_intro.start();
              });
            }

            transition_in(if_block1);
            transition_in(if_block2);
            current = true;
          },
          o(local) {
            transition_out(if_block1);
            transition_out(if_block2);
            current = false;
          },
          d(detaching) {
            if (detaching) detach(div);
            if (if_block0) if_block0.d();
            if (detaching) detach(t1);
            if (if_block1) if_block1.d(detaching);
            if (detaching) detach(t2);
            if (if_block2) if_block2.d(detaching);
            if (detaching) detach(if_block2_anchor);
            mounted = false;
            dispose();
          },
        };
      }

      // (99:12) {#if logoKeyVisible !== true}
      function create_if_block_3(ctx) {
        let t;

        return {
          c() {
            t = text("k");
          },
          m(target, anchor) {
            insert(target, t, anchor);
          },
          d(detaching) {
            if (detaching) detach(t);
          },
        };
      }

      // (101:6) {#if logoKeyVisible === true}
      function create_if_block_2(ctx) {
        let div;
        let div_transition;
        let current;

        return {
          c() {
            div = element("div");
            div.textContent = "key";
            attr(div, "class", "logoKey svelte-3lm3fs");
          },
          m(target, anchor) {
            insert(target, div, anchor);
            current = true;
          },
          i(local) {
            if (current) return;

            add_render_callback(() => {
              if (!div_transition) div_transition = create_bidirectional_transition(div, typewriter, { duration: 2000 }, true);
              div_transition.run(1);
            });

            current = true;
          },
          o(local) {
            if (!div_transition) div_transition = create_bidirectional_transition(div, typewriter, { duration: 2000 }, false);
            div_transition.run(0);
            current = false;
          },
          d(detaching) {
            if (detaching) detach(div);
            if (detaching && div_transition) div_transition.end();
          },
        };
      }

      // (102:6) {#if logoKeyVisible === true}
      function create_if_block_1(ctx) {
        let div;
        let div_transition;
        let current;

        return {
          c() {
            div = element("div");
            div.textContent = "beta";
            attr(div, "class", "logoBeta svelte-3lm3fs");
          },
          m(target, anchor) {
            insert(target, div, anchor);
            current = true;
          },
          i(local) {
            if (current) return;

            add_render_callback(() => {
              if (!div_transition) div_transition = create_bidirectional_transition(div, typewriter, { duration: 2000, delay: 2000 }, true);
              div_transition.run(1);
            });

            current = true;
          },
          o(local) {
            if (!div_transition) div_transition = create_bidirectional_transition(div, typewriter, { duration: 2000, delay: 2000 }, false);
            div_transition.run(0);
            current = false;
          },
          d(detaching) {
            if (detaching) detach(div);
            if (detaching && div_transition) div_transition.end();
          },
        };
      }

      function create_fragment(ctx) {
        let link0;
        let link1;
        let t0;
        let nav;
        let div0;
        let t1;
        let main1;
        let main0;
        let t2;
        let div2;
        let current;
        let if_block = /*visible*/ ctx[0] === true && create_if_block(ctx);
        main0 = new Main({});

        return {
          c() {
            link0 = element("link");
            link1 = element("link");
            t0 = space();
            nav = element("nav");
            div0 = element("div");
            if (if_block) if_block.c();
            t1 = space();
            main1 = element("main");
            create_component(main0.$$.fragment);
            t2 = space();
            div2 = element("div");
            div2.innerHTML = `<div class="contact svelte-3lm3fs"><a href="https://github.com/sateeshsai/trackey" class="svelte-3lm3fs">Github</a></div>`;
            attr(link0, "rel", "icon");
            attr(link0, "href", "./icons/favicon.ico");
            attr(link1, "rel", "manifest");
            attr(link1, "href", "data:application/manifest+json, " + JSON.stringify(/*manifestData*/ ctx[2]));
            attr(div0, "class", "logo svelte-3lm3fs");
            attr(nav, "class", "svelte-3lm3fs");
            attr(main1, "class", "svelte-3lm3fs");
            attr(div2, "class", "footer svelte-3lm3fs");
          },
          m(target, anchor) {
            append(document.head, link0);
            append(document.head, link1);
            insert(target, t0, anchor);
            insert(target, nav, anchor);
            append(nav, div0);
            if (if_block) if_block.m(div0, null);
            insert(target, t1, anchor);
            insert(target, main1, anchor);
            mount_component(main0, main1, null);
            insert(target, t2, anchor);
            insert(target, div2, anchor);
            current = true;
          },
          p(ctx, [dirty]) {
            if (/*visible*/ ctx[0] === true) {
              if (if_block) {
                if_block.p(ctx, dirty);

                if (dirty & /*visible*/ 1) {
                  transition_in(if_block, 1);
                }
              } else {
                if_block = create_if_block(ctx);
                if_block.c();
                transition_in(if_block, 1);
                if_block.m(div0, null);
              }
            } else if (if_block) {
              group_outros();

              transition_out(if_block, 1, 1, () => {
                if_block = null;
              });

              check_outros();
            }
          },
          i(local) {
            if (current) return;
            transition_in(if_block);
            transition_in(main0.$$.fragment, local);
            current = true;
          },
          o(local) {
            transition_out(if_block);
            transition_out(main0.$$.fragment, local);
            current = false;
          },
          d(detaching) {
            detach(link0);
            detach(link1);
            if (detaching) detach(t0);
            if (detaching) detach(nav);
            if (if_block) if_block.d();
            if (detaching) detach(t1);
            if (detaching) detach(main1);
            destroy_component(main0);
            if (detaching) detach(t2);
            if (detaching) detach(div2);
          },
        };
      }

      function instance($$self, $$props, $$invalidate) {
        let visible = false;

        onMount(() => {
          setTimeout(() => {
            $$invalidate(0, (visible = true));
          }, 0);
        });

        let logoKeyVisible = false;

        let manifestData = {
          name: "Trackey",
          short_name: "Trackey",
          description: "Track your time",
          start_url: "",
          display: "fullscreen",
          icons: [
            {
              src: "./icons/favicon-16x16.png",
              sizes: "16x16",
              type: "image/png",
            },
            {
              src: "./icons/favicon-32x32.png",
              sizes: "32x32",
              type: "image/png",
            },
            {
              src: "./icons/android-chrome-192x192.png",
              sizes: "192x192",
              type: "image/png",
            },
            {
              src: "./icons/apple-touch-icon.png",
              sizes: "180x180",
              type: "image/png",
            },
            {
              src: "./icons/android-chrome-512x512.png",
              sizes: "512x512",
              type: "image/png",
            },
          ],
        };

        // Service worker for Progressive Web App
        if ("serviceWorker" in navigator) {
          // console.log("SERVICE WORKER EXISTS");
          navigator.serviceWorker
            .register("serwor.js", {
              scope: "/", // THIS IS REQUIRED FOR RUNNING A PROGRESSIVE WEB APP FROM A NON_ROOT PATH
            })
            .then(
              function (registration) {},
              function (err) {
                // registration failed
                console.log("ServiceWorker registration failed: ", err); // console.log("Registration was successful");
                // console.log("ServiceWorker registration successful with scope: ", registration.scope);
              }
            );
        }

        const introend_handler = () => setTimeout(() => $$invalidate(1, (logoKeyVisible = true)), 500);
        return [visible, logoKeyVisible, manifestData, introend_handler];
      }

      class App extends SvelteComponent {
        constructor(options) {
          super();
          init(this, options, instance, create_fragment, safe_not_equal, {});
        }
      }

      new App({
        target: document.body,
      });
    </script>
    <!-- assets/style.c5a4319c.css -->
    <style type="text/css">
      .sdt-cal-td.svelte-1xp8yha.svelte-1xp8yha {
        padding: 0;
        font-size: 90%;
        text-align: center;
        background-color: var(--sdt-bg-main);
      }
      .sdt-cal-th.svelte-1xp8yha.svelte-1xp8yha {
        height: 24px;
      }
      .sdt-calendar.svelte-1xp8yha.svelte-1xp8yha {
        height: 221px;
        overflow: hidden;
      }
      .sdt-calendar.is-grid.svelte-1xp8yha.svelte-1xp8yha {
        display: grid;
      }
      .sdt-calendar.is-grid.svelte-1xp8yha .sdt-table.svelte-1xp8yha {
        grid-column: 1/2;
        grid-row: 1/2;
      }
      .sdt-table.svelte-1xp8yha.svelte-1xp8yha {
        width: 100%;
        border-collapse: collapse;
      }
      .sdt-table-height.svelte-1xp8yha.svelte-1xp8yha {
        height: 222px;
      }
      .animate-transition.svelte-1xp8yha.svelte-1xp8yha {
        will-change: transform;
        transition: transform 0.3s ease;
      }
      .not-current.svelte-1xp8yha.svelte-1xp8yha {
        opacity: 0.3;
      }
      .not-current.svelte-1xp8yha.svelte-1xp8yha:hover {
        opacity: 0.55;
      }
      .std-btn.svelte-1xp8yha.svelte-1xp8yha {
        margin: 0;
        border: 0;
        background: transparent;
        text-align: center;
        width: 100%;
        border-radius: 4px;
        cursor: pointer;
        padding: 0.3rem;
        box-sizing: border-box;
        color: var(--sdt-color);
      }
      .sdt-btn-day.svelte-1xp8yha.svelte-1xp8yha {
        max-height: 32px;
      }
      .std-btn[disabled].svelte-1xp8yha.svelte-1xp8yha {
        cursor: not-allowed;
        opacity: 0.35;
      }
      .std-btn-header.svelte-1xp8yha.svelte-1xp8yha {
        width: auto;
        font-weight: bold;
        padding: 0.375rem 0.5rem;
      }
      .std-btn-header.icon-btn.svelte-1xp8yha.svelte-1xp8yha:first-of-type {
        padding-left: 0.375rem;
        padding-right: 0.375rem;
      }
      .std-btn-header.icon-btn.svelte-1xp8yha.svelte-1xp8yha {
        padding-left: 0.25rem;
        padding-right: 0.25rem;
      }
      .std-btn.svelte-1xp8yha.svelte-1xp8yha:hover {
        background-color: var(--sdt-btn-bg-hover);
      }
      .is-selected.svelte-1xp8yha .std-btn.svelte-1xp8yha {
        background-color: var(--sdt-primary);
        color: var(--sdt-color-selected, var(--sdt-bg-main));
        opacity: 0.9;
      }
      .std-btn-header.svelte-1xp8yha.svelte-1xp8yha:hover {
        background-color: var(--sdt-btn-header-bg-hover);
      }
      .sdt-time-icon.svelte-1xp8yha.svelte-1xp8yha {
        margin-right: -4px;
      }
      .sdt-time-icon.svelte-1xp8yha svg.svelte-1xp8yha {
        margin: 4px 0;
      }
      .sdt-tbody-lg.svelte-1xp8yha.svelte-1xp8yha {
        background-color: var(--sdt-bg-main);
      }
      .sdt-tbody-lg.svelte-1xp8yha .std-btn.svelte-1xp8yha {
        height: 72px;
      }
      .sdt-thead-nav.svelte-1xp8yha.svelte-1xp8yha {
        display: flex;
        margin-bottom: 0.25rem;
      }
      .sdt-nav-btns.svelte-1xp8yha.svelte-1xp8yha {
        white-space: nowrap;
      }
      .sdt-toggle-btn.svelte-1xp8yha.svelte-1xp8yha {
        width: 100%;
        text-align: left;
      }
      .sdt-today.svelte-1xp8yha.svelte-1xp8yha:before {
        box-sizing: border-box;
        position: absolute;
        content: "";
        margin-left: 4px;
        margin-top: 4px;
        border-left: 4px solid var(--sdt-shadow);
        border-top: 4px solid var(--sdt-shadow);
        border-bottom: 4px solid transparent;
        border-right: 4px solid transparent;
        border-radius: 2px;
        height: 4px;
        z-index: 2;
      }
      .sdt-svg.svelte-1xp8yha.svelte-1xp8yha {
        fill: var(--sdt-color);
      }
      .sdt-today.svelte-1xp8yha.svelte-1xp8yha:hover:before {
        border-left-color: var(--sdt-primary);
        border-top-color: var(--sdt-primary);
      }
      .is-selected.sdt-today.svelte-1xp8yha.svelte-1xp8yha:before {
        border-left-color: #eee;
        border-top-color: #eee;
      }
      .sdt-timer.svelte-yz95cb.svelte-yz95cb {
        position: relative;
        width: 272px;
      }
      .sdt-time-head.svelte-yz95cb.svelte-yz95cb {
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      .sdt-time-figure.svelte-yz95cb.svelte-yz95cb {
        font-size: 1.5rem;
        font-weight: bold;
      }
      .sdt-clock.svelte-yz95cb.svelte-yz95cb {
        margin: auto;
        position: relative;
        width: 260px;
        height: 260px;
        background-color: var(--sdt-clock-bg);
        border-radius: 50%;
        transition: background-color 0.3s;
      }
      .sdt-clock.is-minute-view.svelte-yz95cb.svelte-yz95cb {
        background-color: var(--sdt-clock-bg-minute, var(--sdt-clock-bg));
        box-shadow: var(--sdt-clock-bg-shadow);
      }
      .sdt-time-btn.svelte-yz95cb.svelte-yz95cb {
        border: 0;
        background: transparent;
        text-align: center;
        border-radius: 4px;
        cursor: pointer;
        padding: 0.375rem;
        color: var(--sdt-color);
      }
      .sdt-svg.svelte-yz95cb.svelte-yz95cb {
        fill: var(--sdt-color);
      }
      .sdt-time-btn.svelte-yz95cb.svelte-yz95cb:not(.is-active) {
        opacity: 0.5;
      }
      .sdt-time-btn.svelte-yz95cb.svelte-yz95cb:hover {
        background-color: var(--sdt-btn-header-bg-hover);
      }
      .sdt-back-btn.svelte-yz95cb.svelte-yz95cb {
        position: absolute;
        top: 0;
        left: 0;
        opacity: 1 !important;
      }
      .sdt-meridian.svelte-yz95cb.svelte-yz95cb {
        position: absolute;
        top: 0.25rem;
        right: 0.25rem;
        display: flex;
        flex-flow: column;
        font-size: 90%;
      }
      .sdt-meridian.svelte-yz95cb .sdt-time-btn.svelte-yz95cb {
        padding: 0.15rem 0.5rem;
      }
      .sdt-meridian.svelte-yz95cb .sdt-time-btn.is-active.svelte-yz95cb {
        font-weight: bold;
      }
      .sdt-middle-dot.svelte-yz95cb.svelte-yz95cb {
        left: 50%;
        top: 50%;
        width: 6px;
        height: 6px;
        position: absolute;
        transform: translate(-50%, -50%);
        background-color: var(--sdt-primary);
        border-radius: 50%;
      }
      .sdt-hand-pointer.svelte-yz95cb.svelte-yz95cb {
        width: 2px;
        height: calc(40% + 1px);
        bottom: 50%;
        left: calc(50% - 1px);
        position: absolute;
        background-color: var(--sdt-primary);
        transform-origin: center bottom 0;
        transition: transform 0.3s ease, height 0.15s ease;
      }
      .sdt-hand-circle.svelte-yz95cb.svelte-yz95cb {
        left: -15px;
        top: -21px;
        position: relative;
        width: 4px;
        height: 4px;
        background-color: transparent;
        border: 14px solid var(--sdt-primary);
        border-radius: 50%;
        box-sizing: content-box;
      }
      .sdt-tick.svelte-yz95cb.svelte-yz95cb {
        position: absolute;
        width: 30px;
        height: 30px;
        border-width: 0;
        transform: translate(-50%, -50%);
        text-align: center;
        border-radius: 50%;
        line-height: 20px;
        cursor: pointer;
        background-color: transparent;
      }
      .sdt-tick.is-selected.svelte-yz95cb.svelte-yz95cb {
        animation: svelte-yz95cb-tick-selection 0s 0.175s ease-out forwards;
      }
      @keyframes svelte-yz95cb-tick-selection {
        0% {
          color: initial;
          background-color: transparent;
        }
        100% {
          background-color: var(--sdt-primary);
          color: var(--sdt-color-selected, var(--sdt-bg-main));
        }
      }
      .sdt-calendar-colors.svelte-tb6rom {
        --sdt-primary: #286090;
        --sdt-color: #000;
        --sdt-bg-main: #fff;
        --sdt-bg-today: var(--sdt-primary);
        --sdt-bg-clear: #dc3545;
        --sdt-today-bg: #1e486d;
        --sdt-clear-color: #dc3545;
        --sdt-btn-bg-hover: #eee;
        --sdt-btn-header-bg-hover: #dfdfdf;
        --sdt-clock-bg: #eeeded;
        --sdt-clock-bg-minute: rgb(238, 237, 237, 0.25);
        --sdt-clock-bg-shadow: 0 0 128px 2px #ddd inset;
        --sdt-shadow: #ccc;
      }
      .std-calendar-wrap.svelte-tb6rom {
        width: 280px;
        background-color: var(--sdt-bg-main);
        box-shadow: 0 1px 6px var(--sdt-shadow);
        border-radius: 4px;
        padding: 0.25rem 0.25rem 0.5rem;
        color: var(--sdt-color);
      }
      .std-calendar-wrap.is-popup.svelte-tb6rom {
        box-shadow: 0 1px 6px var(--sdt-shadow);
      }
      .std-btn-row.svelte-tb6rom {
        margin-top: 0.5rem;
        display: flex;
        justify-content: space-evenly;
      }
      .sdt-action-btn.svelte-tb6rom {
        padding: 0.25rem 0.5rem;
        font-size: 0.875rem;
        border-radius: 0.2rem;
      }
      .sdt-today-btn.svelte-tb6rom {
        background-color: var(--sdt-primary);
        color: var(--sdt-today-color, var(--sdt-bg-main));
        padding: 0.25rem 0.5rem;
        font-size: 0.875rem;
        border-radius: 0.2rem;
        border: 1px solid var(--sdt-today-bg);
      }
      .sdt-today-btn[disabled].svelte-tb6rom {
        opacity: 0.75;
      }
      .sdt-today-btn.svelte-tb6rom:focus,
      .sdt-today-btn.svelte-tb6rom:active,
      .sdt-today-btn.svelte-tb6rom:hover:not([disabled]) {
        background-color: var(--sdt-today-bg);
      }
      .sdt-clear-btn.svelte-tb6rom {
        border: 1px solid var(--sdt-clear-color);
        background-color: transparent;
        color: var(--sdt-clear-color);
      }
      .sdt-clear-btn.svelte-tb6rom:focus,
      .sdt-clear-btn.svelte-tb6rom:active:not([disabled]),
      .sdt-clear-btn.svelte-tb6rom:hover:not([disabled]) {
        background-color: var(--sdt-clear-color);
        color: var(--sdt-clear-hover-color, var(--sdt-bg-main));
      }
      .required.svelte-1m7lz7i.svelte-1m7lz7i {
        outline: 0.1rem solid red;
      }
      .addToDo.svelte-1m7lz7i.svelte-1m7lz7i:hover {
        background-color: var(--accentColor);
      }
      .completed.svelte-1m7lz7i.svelte-1m7lz7i {
        text-decoration: line-through;
        text-decoration-color: var(--accentColor);
        text-decoration-thickness: 0.07rem;
        color: var(--lightGrey2);
      }
      ul.svelte-1m7lz7i.svelte-1m7lz7i {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      li.svelte-1m7lz7i.svelte-1m7lz7i {
        padding-left: 0.6rem;
        text-indent: -0.7rem;
        cursor: pointer;
      }
      li.svelte-1m7lz7i.svelte-1m7lz7i::before {
        content: "â€¢ ";
        color: var(--lightGrey2);
      }
      input {
        background-color: var(--lightGrey1);
        border-radius: 0.2rem;
        border: none;
        flex: 1;
      }
      input:focus {
        outline-width: 0;
      }
      .toDoButtonsWrapper.svelte-1m7lz7i.svelte-1m7lz7i {
        display: flex;
        gap: 0.8rem;
      }
      .twoColumn.svelte-1m7lz7i.svelte-1m7lz7i {
        display: flex;
        gap: 2rem;
        align-items: baseline;
        align-content: stretch;
      }
      button.svelte-1m7lz7i.svelte-1m7lz7i {
        max-width: fit-content;
        font-size: 0.9rem;
        background-color: var(--progressGreyFill);
      }
      .hidden.svelte-1m7lz7i.svelte-1m7lz7i {
        display: none;
      }
      form.svelte-1m7lz7i.svelte-1m7lz7i {
        padding: 2rem;
        background-color: var(--grey4);
        border-radius: 1rem;
        display: flex;
        flex-direction: column;
        gap: 2rem;
      }
      fieldset.svelte-1m7lz7i.svelte-1m7lz7i {
        border: none;
        margin: 0;
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
      }
      .options.svelte-1m7lz7i.svelte-1m7lz7i {
        display: flex;
        gap: 0.8rem;
        flex: 1;
      }
      .options.svelte-1m7lz7i input[type="radio"].svelte-1m7lz7i {
        height: 100%;
        display: flex;
        align-items: center;
        text-align: center;
        appearance: none;
        outline: none;
        cursor: pointer;
        border-radius: 0.3rem;
        padding: 0.25rem 0.5rem;
        background-color: var(--progressGreyFill);
        transition: all 0.2s ease-in-out;
        flex: 1;
        border: none;
        color: var(--lightGrey1);
      }
      .options.svelte-1m7lz7i input[type="radio"].svelte-1m7lz7i:checked {
        box-shadow: rgba(17, 17, 26, 0.1) 0px 8px 24px, rgba(17, 17, 26, 0.1) 0px 16px 56px, rgba(17, 17, 26, 0.1) 0px 24px 80px;
        background-color: var(--accentColor);
        color: var(--grey4);
        transform-origin: center;
        font-weight: 700;
      }
      .options.svelte-1m7lz7i input[type="radio"].svelte-1m7lz7i:before {
        content: attr(label);
        display: inline-block;
        text-align: center;
        width: 100%;
      }
      .newToDo.svelte-1m7lz7i.svelte-1m7lz7i {
        flex-direction: row;
      }
      .buttonWrapper.svelte-1bgw4dc {
        display: flex;
        gap: 1rem;
      }
      .newTaskContainer.svelte-1bgw4dc {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 1rem;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1;
      }
      button.cancelTask.svelte-1bgw4dc {
        background-color: var(--lightGrey2);
        color: var(--grey4);
      }
      .buttonWrapper.svelte-1hoasx3 {
        display: flex;
        gap: 1rem;
      }
      .newTaskContainer.svelte-1hoasx3 {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 1rem;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }
      .deleteTask.svelte-1hoasx3 {
        outline: 0.1rem solid red;
      }
      svg.svelte-ugd3ku {
        font-family: "Roboto Mono", monospace;
        color: hsl(0, 0%, 5%);
      }
      ul.svelte-1pi3kc0.svelte-1pi3kc0.svelte-1pi3kc0 {
        list-style: none;
        height: 200px;
        overflow-y: auto;
        padding: 0 0.5rem;
      }
      ul.svelte-1pi3kc0 li.svelte-1pi3kc0.svelte-1pi3kc0 {
        display: flex;
        align-items: center;
        border-bottom: 1px solid hsl(0, 0%, 70%);
        padding: 0.75rem 0;
      }
      ul.svelte-1pi3kc0 > li.svelte-1pi3kc0 + li.svelte-1pi3kc0 {
        margin-top: 1rem;
      }
      ul.svelte-1pi3kc0 li.svelte-1pi3kc0 > .svelte-1pi3kc0 {
        font-weight: 400;
        width: 0;
        flex-grow: 1;
      }
      ul.svelte-1pi3kc0 li h2.svelte-1pi3kc0.svelte-1pi3kc0 {
        text-align: left;
        font-size: 1rem;
      }
      ul.svelte-1pi3kc0 li h2 sup.svelte-1pi3kc0.svelte-1pi3kc0 {
        font-size: 0.75rem;
        margin-left: -0.25rem;
      }
      ul.svelte-1pi3kc0 li h3.svelte-1pi3kc0.svelte-1pi3kc0 {
        text-align: center;
        font-size: 1.15rem;
      }
      ul.svelte-1pi3kc0 li h4.svelte-1pi3kc0.svelte-1pi3kc0 {
        text-align: right;
        font-size: 0.75rem;
      }
      ul.svelte-1pi3kc0.svelte-1pi3kc0.svelte-1pi3kc0::-webkit-scrollbar {
        width: 6px;
      }
      ul.svelte-1pi3kc0.svelte-1pi3kc0.svelte-1pi3kc0::-webkit-scrollbar-track {
        border-radius: 3px;
        background: hsl(0, 0%, 80%);
      }
      ul.svelte-1pi3kc0.svelte-1pi3kc0.svelte-1pi3kc0::-webkit-scrollbar-thumb {
        background-color: hsl(0, 0%, 30%);
        border-radius: 3px;
      }
      div.svelte-16hiinn.svelte-16hiinn {
        display: flex;
        border: 1px solid hsl(0, 0%, 25%);
        border-radius: 20px;
      }
      div.svelte-16hiinn button.svelte-16hiinn {
        font-size: 0.9rem;
        color: hsl(0, 0%, 10%);
        font-family: inherit;
        padding: 0.5rem;
        flex-grow: 1;
        width: 0;
        border: none;
        background: none;
        border-radius: inherit;
        margin: 0;
        transition: background 0.2s ease-out;
      }
      div.svelte-16hiinn button.svelte-16hiinn:not(:first-of-type) {
        border-left: 1px solid hsl(0, 0%, 25%);
        border-top-left-radius: 0;
        border-bottom-left-radius: 0;
      }
      div.svelte-16hiinn button.svelte-16hiinn:focus {
        outline-color: hsl(0, 0%, 25%);
      }
      div.svelte-16hiinn button.svelte-16hiinn:hover {
        background: hsl(0, 0%, 92%);
      }
      .stopwatch {
        display: flex;
        flex-direction: column;
      }
      .stopwatch > * + * {
        margin-top: 0.75rem;
      }
      @supports (display: grid) {
        @media (min-width: 600px) {
          .stopwatch {
            display: grid;
            grid-gap: 20px 50px;
            grid-template-columns: 300px 250px;
            grid-template-rows: 225px auto;
            grid-template-areas: "watch list" "watch controls";
            justify-content: space-between;
          }
          .stopwatch svg {
            grid-area: watch;
            align-self: center;
          }
          .stopwatch ul {
            grid-area: list;
          }
          .stopwatch .controls {
            grid-area: controls;
            align-self: center;
          }
          .stopwatch > * + * {
            margin-top: 0;
          }
        }
      }
      .reportContainer.svelte-n6f8vf {
        border-radius: 1rem;
        background-color: var(--grey4);
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 2rem;
        display: flex;
        flex-direction: column;
      }
      .closeReport.svelte-n6f8vf {
        width: fit-content;
        background-color: var(--grey3);
        align-self: center;
        margin-top: 2rem;
      }
      .task.svelte-n6f8vf {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        border-bottom: 0.1rem solid var(--lightGrey2);
        padding: 1rem 0rem;
        gap: 1rem;
      }
      .taskTime.svelte-n6f8vf {
        text-align: center;
      }
      .header.svelte-n6f8vf {
        font-weight: 800;
      }
      h2.svelte-1747s49 {
        padding-bottom: 2rem;
        text-align: center;
      }
      .container.svelte-1747s49 {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1;
        display: flex;
        flex-direction: column;
        background-color: var(--grey4);
        padding: 2rem;
        position: absolute;
        border-radius: 1rem;
        min-width: 60vw;
      }
      .closeReport.svelte-1747s49 {
        width: fit-content;
        background-color: var(--grey3);
        align-self: center;
        margin-top: 2rem;
      }
      .closeReport.svelte-1747s49:hover {
        background-color: var(--accentColor);
      }
      .task.svelte-1747s49 {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        border-bottom: 0.1rem solid var(--lightGrey2);
        padding: 1rem 1rem;
        gap: 1rem;
        align-items: center;
      }
      .taskTime.svelte-1747s49 {
        text-align: center;
      }
      .header.svelte-1747s49 {
        font-weight: 800;
        border-top: 0.1rem solid var(--lightGrey2);
        border-bottom: none;
      }
      .subheader.svelte-1747s49 {
        background-color: var(--grey2);
        grid-template-columns: 1fr;
        padding: 0.5rem 1rem;
        border: none;
      }
      .statusChange.svelte-1747s49 {
        padding: 0.5rem 1rem;
        background-color: var(--grey2);
        transition: all 0.2s ease;
        border-radius: 0.3rem;
        font-weight: 600;
        cursor: pointer;
        text-align: center;
      }
      .incomplete.svelte-1747s49 {
        background-color: var(--lightGrey1);
        color: var(--grey4);
      }
      .header.svelte-1747s49 {
        font-weight: 600;
      }
      .todoHeading.svelte-1wz5uuo.svelte-1wz5uuo {
        font-weight: 600;
      }
      .close.svelte-1wz5uuo.svelte-1wz5uuo {
        width: fit-content;
        align-self: center;
      }
      .horizonInstructions.svelte-1wz5uuo.svelte-1wz5uuo {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        padding: 2rem;
        border-radius: 1rem;
        background-color: var(--grey3);
      }
      a.svelte-1wz5uuo.svelte-1wz5uuo {
        color: var(--accentColor);
      }
      .instructionWrapper.svelte-1wz5uuo.svelte-1wz5uuo {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        background-color: var(--grey4);
        padding: 1rem;
        border-radius: 1rem;
      }
      h5.svelte-1wz5uuo.svelte-1wz5uuo {
        font-size: 1.2rem;
        color: var(--accentColor);
      }
      p.svelte-1wz5uuo.svelte-1wz5uuo {
        font-size: 1.2rem;
        font-weight: 400;
        line-height: 150%;
      }
      ul.svelte-1wz5uuo.svelte-1wz5uuo {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      li.svelte-1wz5uuo.svelte-1wz5uuo {
        padding-left: 0.6rem;
        text-indent: -0.7rem;
      }
      li.svelte-1wz5uuo.svelte-1wz5uuo::before {
        content: "â€¢ ";
        color: var(--lightGrey2);
      }
      .incompleteList.svelte-1wz5uuo.svelte-1wz5uuo,
      .completedList.svelte-1wz5uuo.svelte-1wz5uuo {
        flex: 1;
        display: flex;
        flex-direction: column;
        font-size: 0.9rem;
      }
      .newTodoTileWrapper.svelte-1wz5uuo.svelte-1wz5uuo {
        display: flex;
        gap: 0.8rem;
        align-items: center;
      }
      .newTodoTileWrapper.svelte-1wz5uuo input.svelte-1wz5uuo {
        width: 80%;
      }
      .tickIcon.svelte-1wz5uuo.svelte-1wz5uuo {
        width: 1.6rem;
        height: 1.6rem;
        background-color: var(--grey3);
        border-radius: 0.2rem;
      }
      .taskModal.svelte-1wz5uuo.svelte-1wz5uuo,
      .newTask.svelte-1wz5uuo.svelte-1wz5uuo,
      .reportModal.svelte-1wz5uuo.svelte-1wz5uuo,
      .completedTasks.svelte-1wz5uuo.svelte-1wz5uuo {
        width: 100vw;
        height: 100vh;
        position: absolute;
        background-color: hsla(0, 0%, 0%, 0.8);
        top: 0;
        z-index: 1;
      }
      .navButtonsWrapper.svelte-1wz5uuo.svelte-1wz5uuo {
        display: flex;
        gap: 1rem;
      }
      button {
        border: 0;
        background-color: var(--grey4);
        color: var(--lightGrey1);
        padding: 0.5rem 0.9rem;
        border-radius: 0.4rem;
        transition: all 0.2s ease;
        cursor: pointer;
        font-weight: 700;
        font-size: 1rem;
      }
      input {
        font-size: 1rem;
        padding: 0.5rem;
      }
      button:hover {
        background-color: var(--accentColor);
        transform: scale(1.05);
        color: var(--grey3);
      }
      .keyTop.svelte-1wz5uuo.svelte-1wz5uuo,
      .keyBottom.svelte-1wz5uuo.svelte-1wz5uuo {
        opacity: 0.9;
      }
      .taskContainer.svelte-1wz5uuo.svelte-1wz5uuo {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 3rem;
      }
      .keyShadow.svelte-1wz5uuo.svelte-1wz5uuo {
        position: relative;
      }
      .taskWrapper.svelte-1wz5uuo.svelte-1wz5uuo {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        color: white;
        margin-top: -3.5%;
      }
      .taskBorder.svelte-1wz5uuo.svelte-1wz5uuo {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1rem;
        background-image: linear-gradient(to bottom right, #2b3139, #272d34, #24282e, #202429, #1d2024, #1c1f23, #1c1e22, #1b1d21, #1d2024, #202227, #22252b, #25282e);
        padding: 1.8rem;
        border-radius: 2rem;
        position: relative;
      }
      .taskBorder.svelte-1wz5uuo.svelte-1wz5uuo::before {
        content: "";
        position: absolute;
        width: calc(100% + 0.5rem);
        height: calc(100% + 0.5rem);
        top: -0.1rem;
        z-index: -1;
        border-radius: 2rem;
        background-image: linear-gradient(to left bottom, #272b30, #292d32, #2b3035, #2e3237, #30353a, #30353a, #30353a, #30353a, #2e3237, #2b3035, #292d32, #272b30);
        border-radius: 2.1rem;
      }
      .taskBorder.svelte-1wz5uuo.svelte-1wz5uuo::after {
        content: "";
        position: absolute;
        width: calc(100% + 0.5rem);
        height: calc(100% + 0.5rem);
        top: 0.3rem;
        z-index: -1;
        border-radius: 2rem;
        border-radius: 2.1rem;
      }
      .keyContainer.svelte-1wz5uuo.svelte-1wz5uuo {
        display: flex;
        justify-content: stretch;
        gap: 0.5rem;
        user-select: none;
        padding: 0 0.5rem;
        background-color: var(--backgroundColor);
        border-radius: 1.5rem;
        flex-wrap: wrap;
        flex: 1 0 25%;
        max-width: 54.5rem;
        padding-top: 0.5rem;
      }
      .keyWrapper.svelte-1wz5uuo.svelte-1wz5uuo {
        width: 13rem;
        height: 13rem;
        overflow: hidden;
        padding-bottom: 0.5rem;
        position: relative;
      }
      .keyWrapper.svelte-1wz5uuo.svelte-1wz5uuo::after {
        position: absolute;
        content: "";
        width: 120%;
        height: 40%;
        bottom: -40%;
        background-image: linear-gradient(
          hsla(210, 6%, 10%, 1) 0%,
          hsla(210, 6%, 10%, 1) 30%,
          hsla(210, 6%, 10%, 1) 80%,
          hsla(210, 6%, 10%, 1) 90%,
          hsla(210, 6%, 10%, 1) 95%,
          hsla(210, 6%, 10%, 1) 100%
        );
        filter: blur(0.3rem);
        left: 50%;
        transform: translateX(-50%);
      }
      .key.svelte-1wz5uuo.svelte-1wz5uuo {
        font-size: 2rem;
        padding: 1rem 3rem 0rem 2.5rem;
        font-weight: 400;
        height: 13rem;
        background-repeat: no-repeat;
        background-size: 100%;
        color: #3d3d44;
        transition: all 0.05s ease;
        -webkit-transition: background-image 0.05s ease-in-out;
        cursor: pointer;
        position: relative;
        border-radius: 0 0 1.2rem 1.2rem;
        display: flex;
        flex-direction: column;
        gap: 4rem;
        justify-content: flex-start;
      }
      .keyBottom.svelte-1wz5uuo.svelte-1wz5uuo {
        font-size: 0.9rem;
        display: flex;
        justify-self: flex-end;
        font-weight: 500;
      }
      .keyPressed.svelte-1wz5uuo.svelte-1wz5uuo {
        transform: translate(0, 10%);
        height: 95%;
      }
      .details.svelte-1wz5uuo.svelte-1wz5uuo {
        display: grid;
        border-radius: 0;
        padding: 0;
        gap: 1.8rem;
        width: 100%;
        grid-template-columns: repeat(var(--gridTemplateColums), 1fr);
      }
      .taskDetailsWrapper.svelte-1wz5uuo.svelte-1wz5uuo {
        font-size: 0.9rem;
        background-color: var(--grey4);
        width: 100%;
        border-radius: 0.8rem;
        display: flex;
        flex-direction: column;
        position: relative;
        min-height: 8rem;
        max-height: 12rem;
        overflow: hidden;
      }
      .todoWrapper.svelte-1wz5uuo.svelte-1wz5uuo {
        overflow: scroll;
      }
      .taskDetailsHeader.svelte-1wz5uuo.svelte-1wz5uuo {
        display: grid;
        grid-template-columns: 10fr auto;
        padding: 1rem;
        align-items: center;
      }
      .addTodo.svelte-1wz5uuo.svelte-1wz5uuo {
        width: 1.5rem;
        height: 1.5rem;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 1.5rem;
        cursor: pointer;
        transition: all 0.2s ease;
        background-color: var(--grey3);
        border-radius: 0.3rem;
        padding: 0.1rem;
      }
      .addTodo::hover svg .e {
        stroke: var(--grey3);
      }
      .addTodo.svelte-1wz5uuo.svelte-1wz5uuo:hover {
        border: none;
        background-color: var(--lightGrey1);
      }
      .taskName.svelte-1wz5uuo.svelte-1wz5uuo {
        font-weight: 700;
        cursor: pointer;
      }
      .taskName.svelte-1wz5uuo.svelte-1wz5uuo:hover {
        color: var(--accentColor);
      }
      .taskDetailsProgress.svelte-1wz5uuo.svelte-1wz5uuo {
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
        position: relative;
      }
      .taskDurationWrapper.svelte-1wz5uuo.svelte-1wz5uuo {
        display: flex;
        justify-content: space-between;
        position: relative;
        padding: 0.2rem 1rem;
        overflow: scroll;
      }
      .taskProgressDuration.svelte-1wz5uuo.svelte-1wz5uuo {
        height: 100%;
        position: absolute;
        width: 100%;
      }
      .taskProgressDuration.svelte-1wz5uuo.svelte-1wz5uuo::after {
        content: "";
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        background-image: linear-gradient(
          to right,
          var(--progressGreyFill) var(--progressPercentage),
          var(--progressGreyFill) var(--progressPercentageStart),
          var(--progressGreyBG) var(--progressPercentageEnd),
          var(--progressGreyBG) 100%
        );
      }
      .active.svelte-1wz5uuo .taskProgressDuration.svelte-1wz5uuo::after {
        content: "";
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        background-image: linear-gradient(
          to right,
          var(--accentColor) var(--progressPercentage),
          var(--accentColor) var(--progressPercentageStart),
          var(--progressGreyBG) var(--progressPercentageEnd),
          var(--progressGreyBG) 100%
        );
      }
      .taskDetailsContent.svelte-1wz5uuo.svelte-1wz5uuo {
        color: var(--lightGrey1);
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        font-weight: 300;
        padding: 1rem;
      }
      .todoLists.svelte-1wz5uuo.svelte-1wz5uuo {
        display: flex;
        flex-direction: column;
      }
      .taskDetailsWrapper.svelte-1wz5uuo.svelte-1wz5uuo {
        padding-bottom: 0.5rem;
      }
      .taskDetailsContent.svelte-1wz5uuo.svelte-1wz5uuo::-webkit-scrollbar-track {
        --webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
      }
      .taskDetailsContent.svelte-1wz5uuo.svelte-1wz5uuo::-webkit-scrollbar {
        width: 0.5rem;
      }
      .taskDetailsContent.svelte-1wz5uuo.svelte-1wz5uuo::-webkit-scrollbar-thumb {
        --webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
        background-color: var(--progressGreyBG);
      }
      .whiteKey.svelte-1wz5uuo.svelte-1wz5uuo {
        background-image: url("./assets/key.png");
      }
      .orangeKey.svelte-1wz5uuo.svelte-1wz5uuo {
        background-image: url("./assets/active-key.png");
        font-weight: 800;
        color: white;
      }
      .orangeKey.svelte-1wz5uuo .keyBottom.svelte-1wz5uuo {
        font-weight: 800;
      }
      .active.svelte-1wz5uuo .taskDurationWrapper.svelte-1wz5uuo {
        font-weight: 800;
        color: white;
      }
      .active.taskDetailsWrapper.svelte-1wz5uuo.svelte-1wz5uuo {
        outline: 0.1rem solid var(--accentColor);
      }
      .active.svelte-1wz5uuo .taskName.svelte-1wz5uuo {
        font-size: 1.3rem;
      }
      .todo.svelte-1wz5uuo.svelte-1wz5uuo {
        cursor: pointer;
        padding-top: 0.5rem;
      }
      .completedTodo.svelte-1wz5uuo.svelte-1wz5uuo {
        text-decoration: line-through;
        text-decoration-color: var(--accentColor);
        text-decoration-thickness: 0.07rem;
      }
      .contact.svelte-3lm3fs.svelte-3lm3fs {
        padding: 0.3rem 0.5rem;
        border-radius: 0.3rem;
        border: 0.1rem solid var(--lightGrey2);
        text-align: center;
        box-sizing: border-box;
        font-size: 0.8rem;
      }
      .footer.svelte-3lm3fs.svelte-3lm3fs {
        width: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        position: absolute;
        bottom: 0;
        padding: 2rem;
      }
      a.svelte-3lm3fs.svelte-3lm3fs {
        color: var(--lightGrey1);
        text-decoration: none;
      }
      .logoBeta.svelte-3lm3fs.svelte-3lm3fs {
        font-size: 0.7rem;
        color: var(--lightGrey2);
        font-weight: 400;
        display: flex;
        position: relative;
      }
      * {
        box-sizing: border-box;
        padding: 0;
        margin: 0;
      }
      html {
        font-size: clamp(6px, calc(0.45vw + 0.45vh + 0.15vmin), 22px);
      }
      .scrollbar-hidden::-webkit-scrollbar {
        display: none;
      }
      .scrollbar-hidden {
        -ms-overflow-style: none;
        scrollbar-width: none;
      }
      ::-webkit-scrollbar {
        width: 0;
        height: 0;
        background: transparent;
      }
      body {
        color: var(--lightGrey1);
        font-family: "Inter", sans-serif;
        --backgroundColor: #121416;
        --grey2: hsl(220, 10%, 25%);
        --grey3: hsl(220, 10%, 20%);
        --grey4: hsl(220, 10%, 15%);
        --grey5: hsl(220, 10%, 5%);
        --lightGrey0: hsl(220, 10%, 80%);
        --lightGrey1: hsl(220, 10%, 70%);
        --lightGrey2: hsl(220, 6%, 45%);
        --accentColor: hsl(108, 72%, 40%);
        --progressGreyFill: #484d53;
        --progressGreyFill: hsl(223deg 9% 27%);
        --progressGreyBG: hsl(223deg 9% 20%);
        background-color: var(--backgroundColor);
      }
      nav.svelte-3lm3fs.svelte-3lm3fs {
        display: flex;
        justify-content: center;
        flex: 1;
        background-color: var(--grey5);
        padding: 1.5rem 3rem;
      }
      .logo.svelte-3lm3fs.svelte-3lm3fs {
        font-size: 2rem;
        font-weight: 900;
        color: var(--lightGrey0);
        display: flex;
        margin-right: 1rem;
      }
      .logo.svelte-3lm3fs .logoKey.svelte-3lm3fs {
        color: var(--accentColor);
        margin: 0;
        padding: 0;
      }
      main.svelte-3lm3fs.svelte-3lm3fs {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 3rem;
        padding: 5rem 3rem;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
  </body>
</html>
